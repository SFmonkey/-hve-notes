{
  "posts": [
    {
      "content": "### 概要\n\nwebpack 是前端最常用的**模块打包工具**了，关于它的知识，我们从使用和原理两方面来讨论下。\n\n* Webpack 使用\n\t* 基础配置\n\t* webpack 优化\n* Webpack 原理\n\t* Loader 和 Plugin 的区别\n\t* 如何保证各个 loader 按照预想方式工作\n\t* Webpack 构建流程\n\t* 文件监听原理\n\t* Webpack 热更新原理\n\t* 代码分割的本质与意义\n\t* Babel 原理\n* Webpack 实现\n\t* 实现一个简单的 Webpack\n\t* 实现一个Loader\n\t* 实现一个Plugin\n\n### 使用\n\n#### 基础配置\n\n* Loader\n\n\t* JavaScript 相关\n\t\n\t\t* babel-loader\n\t\t\t\n\t\t\t将 ES6 + 的语法转换成 ES5\n\t\t\t\n\t\t* ts-loader\n\t\t\n\t\t\t将 Typescript 转换成 Javascript\n\t\t\n\t\t* awesome-typescript-loader\n\t\t\t\n\t\t\t将 TypeScript 转换成 JavaScript， 性能优于 ts-loader\n\t\n\t\t* eslint-loader\n\n\t\t\t通过 ESLint 检查 Javascript 代码\n\t\t\t\n\t\t* tslint-loader\n\n\t\t\t通过 tslint 检查 TypeScript 代码\n\t\t\t\n\t\t* vue-loader\n\n\t\t\t加载 Vuejs 单文件组件\n\t\t\t\n\t* CSS 相关\n\n\t\t* sass-loader\n\n\t\t\t将 SCSS/SASS 代码转换成 CSS\n\t\t\t\n\t\t* postcss-loader\n\t\t\t\n\t\t\t扩展 CSS 语法，使用下一代 CSS，例如可以配合 autoprefixer 插件自动补齐 CSS3 前缀\n\t\t\t\n\t\t* css-loader\n\n\t\t\t加载 CSS，支持模块化，压缩，文件导入等特性\n\t\t\t\n\t\t* style-loader\n\n\t\t\t将 CSS 代码通过 style 标签的方式加载进 html\n\t\t\t\n\t* 文件相关\n\n\t\t* file-loader\n\n\t\t\t将文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件（处理图片和字体）\n\n\t\t* url-loader\n\n\t\t\t与 file-loader 类似，区别是用户可以设置一个阈值，小于阈值时返回文件的 base64 形式编码（处理图片和字体）\n\n\t\t* raw-loader\n\n\t\t\t将文件内容通过字符串形式输出（utf-8）\n\n\t* 优化相关\n\n\t\t* cache-loader\n\n\t\t\t可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存在磁盘里\n\n\t\t* thread-loader\n\n\t\t\t与 cache-loader 使用效果与位置相同\n\t\t\t\t\n* Plugins\n\n\t* 通用插件\n\t\n\t\t* clean-webpack-plugin \n\t\t\n\t\t\t目录清理\n\t\t\t\n\t\t* html-webpack-plugin\n\n\t\t\t简化 HTML 文件创建（可以指定 template 以及自动引入入口文件）\n\t\t\t\n\t\t* webpack.ProvidePlugin\n\n\t\t\t定义全局变量，不必到处 require 或 import\n\t\t\t\n\t\t* HappyPack\n\n\t\t\t多进程打包\n\t\t\t\n\t\t* webpack.DefinePlugin\n\n\t\t\t定义环境变量（在项目代码中可能存在需要环境变量的情况）\n\t\n\t* 开发插件\n\t\t\t\n\t\t* HotModuleReplacementPlugin\n\n\t\t\twebpack 的热更新又称热替换（HMR），这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块\n\t\t\t\n\t* 生产插件\n\n\t\t* mini-css-extract-plugin\n\t\t\t\n\t\t\t分离样式文件，CSS 提取为独立文件，支持按需加载\n\t\t\t\n\t\t* workbox-webpack-plugin\n\n\t\t\t为网页应用增加离线缓存功能\n\t\t\t\n\t\t* purifycss-webpack\n\n\t\t\t利用该插件进行 css treeshaking\n\t\t\t\n\t\t* webpack.DllReferencePlugin\n\n\t\t\t根据 DllPlugin 生成的 manifest 文件，对 bundle 文件进行映射\n\t\t\t\n\t\t* add-asset-html-webpack-plugin\n\n\t\t  将指定的静态文件写入 html \n\n\t\t* webpack-bundle-analyzer\n\n\t\t\t可视化 webpack 输出文件的体积（业务组件，第三方组件）\n\t\t\t\n* 其他配置\n\t\t\t\n\t* 文件指纹：文件指纹是打包输出的文件名的后缀，一共分三种\n\t\t* Hash\n\t\t\t和整个项目的构建有关，只要项目文件有修改，整个项目构建的hash值就会更改\n\t\t\t\n\t\t\t设置 file-loader 的name，使用hash\n\t\t\t\n\t\t* Chunkhash\n\t\t\t和 webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash\n\t\t\t\n\t\t\t设置 output 的 filename， 用 chunkhash\n\t\t\t\n\t\t* Contenthash\n\t\t\t根据文件内容来定义 hash，文件内容不变，则 contenthash 不变\n\t\t\t\n\t\t\t设置 MiniCssExtractPlugin 的 filename， 使用 contenthash\n\t\t\t\n\t* optimization\n\t\t\n#### webpack 优化\n\n* 提升webpack构建速度\n\n\t* 多进程/多实例构建\n\t\n\t\tHappyPack 和 thread-loader\n\t\n\t* 多进程压缩代码\n\t\t\n\t\tterser-webpack-plugin 开启 parallel 参数\n\t\t\n\t* 缩小打包作用域\n\t\t* exclude/inlcude （确定 loader 规则范围）\n\t\t* resolve.modules 指明第三方模块的绝对路径\n\t\t* resolve.mainFields 只采用 main 字段作为入口文件描述字段\n\t\t* resolve.extensions 尽可能减少后缀尝试的可能性\n\t\t* 合理使用alias\n\n\t* DLL\n\n\t\t使用 DllPlugin 进行分包，使用 DllReferencePlugin 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译\n\t\t\n\t* 充分利用缓存提升二次构建速度\n\n\t\t* babel-loader 开启缓存\n\t\t* terser-webpack-plugin 开启缓存\n\t\t* cache-loader\n\n* 提升页面加载速度\n\n\t* 动态 Polyfill\n\t\t[babel polyfill](https://sfmonkey.github.io/post/babel-polyfill/)\n\t* Scope hoisting\n\t\t* 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。\n\t\t\t```js\n\t\t\t//开启前\n\t\t\t[\n\t\t\t\t\t/* 0 */\n\t\t\t\t\tfunction(module, exports, require) {\n\t\t\t\t\t\t\tvar module_a = require(1)\n\t\t\t\t\t\t\tconsole.log(module_a['default'])\n\t\t\t\t\t}\n\n\t\t\t\t\t/* 1 */\n\t\t\t\t\tfunction(module, exports, require) {\n\t\t\t\t\t\t\texports['default'] = 'module A'\n\t\t\t\t\t}\n\t\t\t]\n\n\t\t\t//开启后,通过减少闭包和函数声明，来减少代码体积和内存开销\n\t\t\t[\n\t\t\t\t\tfunction(module, exports, require) {\n\t\t\t\t\t\t\tvar module_a_defaultExport = 'module A'\n\t\t\t\t\t\t\tconsole.log(module_a_defaultExport)\n\t\t\t\t\t}\n\t\t\t]\n\t\t\t```\n\t\t* 必须是 ES6 的语法，因为有很多第三方库仍采用 CommonJs 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 main 指向 ES6 模块化语法\n\t* Tree shaking\n\t\t* 打包过程中检测工程中没有引入过的模块进行标记，在资源压缩时将它们从最终的 bundle 中去掉（[只能对 ES6 module 生效](https://juejin.im/post/5a5652d8f265da3e497ff3de)），开发中尽可能使用 ES6 module 的模块，提高 tree shaking 效率。\n\t\t* 禁用 babel-loader 的模块依赖解析，否则 webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking\n\t\t* 使用 PurifyCSS（不再维护）或者 uncss 去除无用 css 代码\n\t* 提取页面公共资源\n\t\t* 将基础包通过 externals 或者 dll 方式 CDN 引入，不打入 bundle 中\n\t\t* 使用 SplitChunksPlugin 进行代码分割\n\t* 图片压缩，配置 image-webpack-loader\n\t* 提取 CSS 文件，通过css-loader的 minimize 选项开启 cssnano 压缩 CSS\n\t\n### webpack 原理\n\n* Loader 和 Plugin 的区别\n\n\t**Loader 本质就是一个函数**，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\n\t\n\t**Plugin 就是插件，插件可以扩展 webpack 的功能**，在 webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。\n\t\n\t**Loader** 在 module.rules 中配置，作为模块的解析规则，类型为数组。每项都是一个 Object， 内部包含了 test，loader，options 等属性。\n\t\n\t**Plugin** 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。\n\t\n* 如何保证各个 loader 按照预想方式工作\n\n\trules 中的每个 Object 都可以配置一个key **enforce**，value 一般有两个 **pre** **post**，pre 代表在所有正常 loader 之前执行，post 在所有 loader 之后执行。\n\t\n* Webpack 构建流程\n\n\twebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\t\n\t* 读取 webpack 配置\n\t\n\t\t* 从配置文件中读取参数\n\n\t* 分析入口文件\n\n\t\t* 分析依赖模块\n\t\t* 分析入口文件内容\n\t\t* 编译内容\n\n\t* 依赖模块\n\n\t\t* 分析依赖模块\n\t\t* 分析本文件内容\n\t\t* 编译内容\n\t\t\n\t* 生成 bundlejs\n\n* 文件监听原理\n\n\t文件监听是指 **webpack --watch**  或者 config 中配置 **watch 属性为 true**\n\n\t缺点： 每次都需要手动更新浏览器\n\t\n\t原理： 轮询判断文件的最后编辑时间是否变化，如果某个文件发生变化，并不会立刻告诉监听者，而是先缓存起来，等 **aggregateTimeout** 后再执行。\n\t\n\t```js\n\tmodule.export = {    \n\t\t// 默认false,也就是不开启    \n\t\twatch: true,    \n\t\t// 只有开启监听模式时，watchOptions才有意义    \n\t\twatchOptions: {        \n\t\t// 默认为空，不监听的文件或者文件夹，支持正则匹配       \n\t\tignored: /node_modules/,        \n\t\t// 监听到变化发生后会等300ms再去执行，默认300ms        \n\t\taggregateTimeout:300,        \n\t\t// 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次        \n\t\tpoll:1000    \n\t}}\n\t```\n\t\n\t\n* Webpack 热更新原理\n\n\tHMR 可以做到在不刷新浏览器的情况下用新变更的模块替换掉旧的模块\n\t\n\tHMR 的核心就是客户端从服务器拉取更新后的文件，准确的说是 chunk diff（chunk 需要更新的部分），**实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器发送更新通知**，并带上构建时的 hash，让客户端与上一次资源进行对比。**客户端对比出差异后会向 WDS 发送 Ajax 请求来获取更改内容**（文件列表，hash），这样客户端就可以再借助这些信息继续向 WDS 发送 jsonp 请求获取该 chunk 的增量更新。**客户端拿到增量更新后，由 HotMoudlePlugin 提供相关 API 以供开发者针对自身场景进行处理**，react-hot-loader 和 vue-loader 都是借助这些 API 实现的 HMR\n\n\t> WDS->websocket->客户端->Ajax->更新内容->HotMoudlePlugin->react-hot-loader/vue-loader->HMR\n\n\t* 代码分割的本质与意义\n\n\t代码分割本质其实就是在 **源代码直接上线** 和 **打包成唯一脚本** 这两种极端方案之间的一种更适合实际场景的中间状态。\n\n* Babel 原理\n\n\t* 解析：将代码转换成 AST\n\t\t* 词法分析：将代码字符串分割为 token 流，即语法单元组成的数组\n\t\t* 语法分析：分析 token 流（上面生成的数组）并生成 AST\n\t* 转换：访问 AST 的节点进行变换操作生产新的 AST\n\t* 生成：以新的 AST 为基础生成代码\n\n### Webpack 实现\n\n#### 实现一个简单的 Webpack\n\n原理：\n\n1. 读取 webpack 配置\n2. 分析入口模块\n\t* 获取入口依赖\n\t* 获取入口内容\n\t* 转译入口内容\n3. 分析依赖模块\n\t* 获取模块依赖\n\t* 获取模块内容\n\t* 转译模块内容\n4. 得到 bundle.js\n\n实现：\n\n```js\nconst path = require('path');\nconst fs = require('fs');\nconst babel = require('@babel/core');\nconst parser = require('@babel/parser');\nconst traverse = require('@babel/traverse').default;\n\n\nclass compiler {\n    constructor(opt) {\n        this.opt = opt;\n    }\n\n    run() {\n        const {entry, output} = this.opt;\n\n        const res = this.generateCode(entry);\n\n        fs.writeFileSync(path.resolve(output.path, output.filename), res);\n    }\n\n    moduleAnalyze(filename) {\n        const content = fs.readFileSync(filename, 'utf-8');\n        // 分析内容\n        const ast = parser.parse(content, {\n            sourceType: \"module\"\n        });\n\n        const dependencies = {};\n        // 分析依赖模块路径\n        traverse(ast, {\n            ImportDeclaration({node}){\n                const dirname = path.dirname(filename);\n                const genFile = './' + path.join(dirname, node.source.value);\n                dependencies[node.source.value] = genFile;\n            }\n        });\n        // 编译内容\n        const {code} = babel.transformFromAst(ast, null, {\n            presets: ['@babel/preset-env']\n        });\n\n        return {\n            filename,\n            dependencies,\n            code\n        }\n    }\n\n    graphAnalyze(entry) {\n        // 分析入口模块\n        const entryModule = this.moduleAnalyze(entry);\n        const graphArr = [entryModule];\n\n        // 分析依赖模块\n        graphArr.forEach(v => {\n            const {dependencies} = v;\n\n            if (dependencies) {\n                for(let key in dependencies) {\n                    graphArr.push(this.moduleAnalyze(dependencies[key]));\n                }\n            }\n        });\n        \n        const graph = {};\n\n        graphArr.forEach(v => {\n            graph[v.filename] = {\n                dependencies: v.dependencies,\n                code: v.code\n            }\n        });\n\n        return graph;\n    }\n\n    // 生成结果代码\n    generateCode(entry) {\n        // 得到所有模块图谱\n        const graph = JSON.stringify(this.graphAnalyze(entry));\n        // 输出 bundle.js\n        return `(function(graph){\n            // 浏览器没有 require ，所以我们需要实现一个\n            function require(module) {\n                function localRequire(relativePath) {\n                    return require(graph[module].dependencies[relativePath]);\n                }\n\n                var exports = {};\n                (function(require, exports, code){\n                    eval(code);\n                })(localRequire, exports, graph[module].code);\n\n                return exports;\n            }\n\n            require('${entry}')\n        })(${graph})`;\n    }\n}\n\nmodule.exports = compiler;\n```\n\n#### 实现一个Loader\n\n```js\nconst chalk = require('chalk');\n\nmodule.exports = function(content) {\n    const warning = chalk.keyword('orange');\n    const { notice } = this.query;\n    let words = ['todo', 'fixme', 'review'];\n\n    if (notice && Array.isArray(notice) && notice.length > 0) {\n        words = notice;\n    }\n\n    const reg = new RegExp(`(\\/\\/\\\\s*(${words.join(\"|\")}).*$)|(\\/\\\\*[\\\\s\\\\S]*(${words.join(\"|\")})[\\\\s\\\\S]*\\\\*\\/)`, \"igm\");\n    const res = content.match(reg)\n\n    if (res && res.length > 0) {\n        const len = res.length;\n\n        this.emitWarning(warning(`\n\n           \n        ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗\n        ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝\n        ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗  \n        ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝  \n        ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗\n        ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝\n                                               \n   \n                                        \n        There are ${len} ${len > 1 ? 'comments' : 'comment'} you might to notice in ${chalk.green(this.resourcePath)}\n        \n        `));\n    }\n\n    return content;\n}\n```\n\n#### 实现一个Plugin\n\n* 一个JavaScript类函数\n* 在函数原型 (prototype)中定义一个注入compiler对象的apply方法\n* apply函数中通过compiler插入指定的事件钩子,在钩子回调中拿到compilation对象\n* 使用compilation操纵修改webapack内部实例数据\n* 异步插件，数据处理完后使用callback回调\n\n**Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译**\n\n```js\nclass EndPlugin {\n    constructor(options) {\n        const {doneCb, failCb} = options;\n\n        this.doneCallback = doneCb;\n        this.failCallback = failCb;\n    }\n\n    apply(compiler) {\n        compiler.plugin('done', stats => {\n            this.doneCallback && this.doneCallback(stats);\n        });\n\n        compiler.plugin('failed', error => {\n            this.failCallback && this.failCallback(error);\n        });\n    }\n}\n\nmodule.exports = EndPlugin;\n```\n\n\n### 参考资料\n\n* [「吐血整理」再来一打Webpack面试题🔥(持续更新)](https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5#heading-16)\n* [Webpack 4进阶--从前的日色变得慢 ，一下午只够打一次包](https://zhuanlan.zhihu.com/p/35407642)\n* [手写一个webpack插件](https://segmentfault.com/a/1190000019010101)\n* [玩转webpack之loader开发](https://imweb.io/topic/5d4a94a08db073cf44ca8cd0)\n* [webpack loader和plugin编写](https://juejin.im/post/5bbf190de51d450ea52fffd3)\n\n\n\t\n",
      "data": {
        "title": "Webpack Essay",
        "date": "2020-03-25 08:56:36",
        "tags": [
          "webpack",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "webpack-essay"
    },
    {
      "content": "### 概要\n\n当我们了解 stck reconciler（react 16.0 之前的 diff 算法）后，我们知道 React 在大型项目中， setState 处理更新时，会因为虚拟DOM 进行 diff 而**一鼓作气**长时间占用主线程，去比较该组件及其子组件，导致一些高级别的任务，比如用户输入和动画执行出现延迟卡顿，而 Fiber 在 react 中的引入，就是为了解决这个问题。\n\n**如果是100米短跑，或者1000米竞赛，当然越快越好。如果是马拉松，就需要考虑到保存体力了，需要注意休息了。性能是一个系统性的工程。**\n\n\n既然我们要去和 fiber 做朋友了，那我们就需要去尝试了解一下它，它是怎么做到能够解决上面的问题的\n\n* requestIdleCallback\n\n* vdom 树形 转换到 Fiber 链式（Reconciliation Phase）\n\n* 🚢新的 diff 算法（Reconciliation Phase）\n\n* Fiber 转换为真实 DOM（Commit Phase）\n\n### requestIdleCallback\n\n**requestIdleCallback 是在浏览器空闲时会执行对应 callback 的 API**\n\n页面一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。\n\n1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。\n\n![](https://sfmonkey.github.io//post-images/1584699602216.jpeg)\n\n这是浏览器一帧内的工作\n\n上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 requestIdleCallback 里注册的任务。\n\n### Fiber\n\n* 因为 createElement 返回的结果是 vnode ，我们需要将 vnode 树转换为 fiber 链表。因为链表的结构天然适合我们进行任务的暂停。\n\n\t```js\n\t//ReactDom.js\n\n\t// 下一个单元任务\n\t// let nextUnitOfWork = null;\n\t// work in progress 工作中的 fiber root\n\tlet wrokInProgressRoot = null;\n\t// 现在的根节点\n\tlet currentRoot = null;\n\n\tfunction render(vnode, container) {\n\t\twrokInProgressRoot = {\n\t\t\tnode: container,\n\t\t\tprops: {children: [vnode]},\n\t\t\tbase: currentRoot\n\t\t}\n\n\t\tnextUnitOfWork = wrokInProgressRoot;\n\t}\n\n\tfunction reconcilerChilren(workInProgressFiber, children) {\n\t\tlet prevSibling = null;\n\t\tlet oldFiber = workInProgressFiber.base && workInProgressFiber.base.child;\n\t\tfor(let i = 0; i < children.length; i ++) {\n\t\t\tlet child = children[i];\n\t\t\tlet newFiber = null;\n\n\t\t\tnewFiber = {\n\t\t\t\ttype: child.type,\n\t\t\t\tprops: child.props,\n\t\t\t\tnode: null,\n\t\t\t\tbase: null,\n\t\t\t\tparent: workInProgressFiber,\n\t\t\t\teffectTag: PLACEMENT\n\t\t\t}\n\n\t\t\tif (oldFiber) {\n\t\t\t\toldFiber = oldFiber.sibling\n\t\t\t}\n\n\t\t\tif (i === 0) {\n\t\t\t\tworkInProgressFiber.child = newFiber;\n\t\t\t} else {\n\t\t\t\tprevSibling.sibiling = newFiber;\n\t\t\t}\n\n\t\t\tprevSibling = newFiber;\n\t\t}\n\t}\n\n\tfunction updateClassComponent(fiber) {\n\t\tconst {type, props} = fiber;\n\t\tconst cmp = new type(props);\n\t\tconst children = [cmp.render()];\n\t\treconcilerChilren(fiber, children);\n\t}\n\n\tfunction updateFunctionComponent(fiber) {\n\t\tconst {type, props} = fiber;\n\t\tconst children = [type(props)];\n\t\treconcilerChilren(fiber, children);\n\t}\n\n\tfunction updateHostComponent(fiber) {\n\t\tif (!fiber.node) {\n\t\t\tfiber.node = createNode(fiber);\n\t\t}\n\n\t\tconst children = fiber.props;\n\t\treconcilerChilren(fiber, children);\n\t}\n\n\tfunction preformUnitOfWork (fiber) {\n\t\tconst {type} = fiber;\n\t\n\t\tif (typeof type === 'function') {\n\t\t\ttype.isReactComponent ? \n\t\t\t\tupdateClassComponent(fiber) : \n\t\t\t\tupdateFunctionComponent(fiber)\n\t\t} else {\n\t\t\tupdateHostComponent(fiber);\n\t\t}\n\n\t\tif (fiber.child) {\n\t\t\treturn fiber.child;\n\t\t}\n\n\t\tlet nextFiber = fiber;\n\t\twhile(nextFiber) {\n\t\t\tif (nextFiber.sibling) {\n\t\t\t\treturn nextFiber.sibling\n\t\t\t}\n\t\t\tnextFiber = nextFiber.parent;\n\t\t}\n\t}\n\n\tfunction workLoop(deadline) {\n\t\twhile(nextUnitOfWork && deadline.timeRemaining() > 1) {\n\t\t\tnextUnitOfWork = preformUnitOfWork(nextUnitOfWork);\n\t\t}\n\n\t\tif (!nextUnitOfWork && wrokInProgressRoot) {\n\t\t\tcommitRoot();\n\t\t}\n\t}\n\n\trequestIdleCallback(workLoop)\n\t```\n\n* Fiber diff算法\n\t待更新\n\t\n* 然后，我们需要在 Commit Phase 阶段，将 Fiber 转换为真实 DOM，在 Reconcilition Phase 阶段我们可以暂停去执行其他高优先级任务，但是在 Commit 阶段，这个更新是一气呵成的，因为这是用户要看到的 UI 阶段。\n\n\t```js\n\tfunction commitRoot() {\n\t\tcommitWorker(wrokInProgressRoot.child);\n\t\tcurrentRoot = wrokInProgressRoot;\n\t\twrokInProgressRoot = null;\n\t}\n\n\tfunction commitWorker(fiber) {\n\t\tif(!fiber) {\n\t\t\treturn\n\t\t}\n\n\t\tlet parentNodeFiber = fiber.parent;\n\t\twhile (!parentNodeFiber.node) {\n\t\t\tparentNodeFiber = parentNodeFiber.parent;\n\t\t}\n\n\t\tconst parentNode = parentNodeFiber.node;\n\t\t// 更新 删除 新增\n\t\tif (fiber.effectTag === PLACEMENT && fiber.node !== null) {\n\t\t\tparentNode.appendChild(fiber.node);\n\t\t}\n\t\tcommitWorker(fiber.child);\n\t\tcommitWorker(fiber.sibling);\n\t}\n\t```\n\n### 参考资料\n\n* [利用好浏览器的空闲时间 --- requestIdleCallback](https://www.cnblogs.com/Wayou/p/requestIdleCallback.html)\n* [React Fiber](https://juejin.im/post/5ab7b3a2f265da2378403e57)\n* [完全理解React Fiber](http://www.ayqy.net/blog/dive-into-react-fiber/)\n* [React Fiber架构](https://zhuanlan.zhihu.com/p/37095662)\n\n\n\n\n\n",
      "data": {
        "title": "React Fiber Essay",
        "date": "2020-03-20 16:47:23",
        "tags": [
          "React",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/react-fiber-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-fiber-essay"
    },
    {
      "content": "### 概要\n我们都知道，react 中是通过 setState 来触发组件 render 函数，得到虚拟 DOM，然后 oldVnode 与 vnode 进行 diff ，最后得到高效的 DOM 更新操作。\n\n在 React diff 中，更新策略有三点\n\n1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计\n2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构\n3. 对于同一层级的一组子节点，他们可以通过唯一 id 进行区分\n\n基于这三个更新策略，我们可以得出 React diff 中三种不同的 diff 类型\n\n1. tree diff\n2. component diff\n3. element diff\n\n### tree diff\n\nReact 对🌲的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。\n\n* 首先我们来控制同层比较\n\n\t```js\n\t_updateChildren: function(      \n\t\tnextNestedChildrenElements,\n\t\ttransaction,\n\t\tcontext,\n\t) {\n\t\t...\n\t\tvar nextChildren = this._reconcilerUpdateChildren(\n\t\t\tprevChildren,\n\t\t\tnextNestedChildrenElements,\n\t\t\tmountImages,\n\t\t\tremovedNodes,\n\t\t\ttransaction,\n\t\t\tcontext,\n\t\t);\n\t}\n\t```\n\n\tprevChildren 和 nextChildren 就是对应的虚拟 DOM，nextNestedChildrenElements 这玩意儿是个指针，来标明当前树的层次，得到当前 prevChildren 的层次。\n\n* 然后 ReactChildReconciler.updateChildren 会将 prevChildren、nextChildren封装成ReactDOMComponent类型，并进行后续比较和操作。\n\n所以当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 **React 官方建议不压迫进行 DOM 节点跨层级的操作**\n\n![](https://sfmonkey.github.io//post-images/1584599830004.jpeg)\n\n### component diff\n\n我们需要清楚的是，createElement 生成的虚拟 DOM，如果节点本身是组件，那么虚拟 DOM 中的 tag 其实就是对应的 class 或者 function，这个在之前我们实现 react 的时候就已经有体现了。当然这是 react 虚拟 DOM，在 vue 中 tag 不太一样，这是后话。\n\n* 如果是同一类型的组件，按照原策略继续比较虚拟 DOM 树\n\n* 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点\n\n* 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，这是我们可以通过 shouldComponentUpdate 钩子来告诉该组件是否进行 diff，从而提高大量的性能。\n\n\t```\n\t// 超简单代码实现\n\tconst compareTwoVnodes(oldVnode, newVnode, dom) {\n\t\t\tlet newNode = dom\n\n\t\t\t// 如果新的虚拟DOM是null，那么就将前一次的真实DOM移除掉\n\t\t\tif (newVnode == null) {\n\t\t\t\t\tdestroyVnode(oldVnode, dom)\n\t\t\t\t\tdom.parentNode.removeChild(dom)\n\n\t\t\t} else if (oldVnode.type !== newVnode.type || oldVnode.key !== newVnode.key) {\n\t\t\t\t\t// replace\n\t\t\t\t\tdestroyVnode(oldVnode, dom)\n\t\t\t\t\tnewNode = initVnode(newVnode, parentContext, dom.namespaceURI)\n\t\t\t\t\tdom.parentNode.replaceChild(newNode, dom)\n\n\t\t\t} else if (oldVnode !== newVnode || parentContext) {\n\t\t\t\t\t// same type and same key -> update\n\t\t\t\t\tnewNode = updateVNode(oldVnode, newVnode, dom, parentContext)\n\t\t\t}\n\t}\n\t/** \n\t* 更新虚拟DOM\n\t* 这里的type需要注意一下，如果vnode是个html元素，例如h1，那么type就是'h1'\n\t** 如果vnode是一个函数组件，例如const Header = () => <h1>header</h1>，那么type就是函数Header\n\t** 如果vnode是一个class组件，那么type就是那个class\n\t*/\n\tconst updateVNode = (vnode, node) => {\n\t\t\tconst { type } = vnode; // type是指虚拟DOM的类型\n\t\t\t// 如果是class组件\n\t\t\tif (type === VCOMPONENT) {\n\t\t\t\t\treturn updateComponent(vnode, node)\n\t\t\t} else (type === VSTATELESS){\n\t\t\t\t\treturn updateStateLess(vnode, node)\n\t\t\t}\n\t\t\tupdateVChildren(vnode, node)\n\t}\n\t// 更新class组件（调用render方法拿到新的虚拟DOM）\n\tconst updateComponent = (vnode, node) => {\n\t\t\tconst { type: Component } = vnode; // type是指虚拟DOM的类型\n\t\t\tconst newVNode = new Component().render();\n\t\t\tcompareTwoVnodes(newVNode, vnode, node);\n\t}\n\t// 更新无状态组件（直接执行函数拿到新的虚拟DOM）\n\tconst updateStateLess = (vnode, node) => {\n\t\t\tconst { type: Component } = vnode; // type是指虚拟DOM的类型\n\t\t\tconst newVNode = Component();\n\t\t\tcompareTwoVnodes(newVNode, vnode, node);\n\t}\n\tconst updateVChildren = (vnode, node) => {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tupdateVNode(vnode.children[i], node.children[i])\n\t\t\t}\n\t}\n\t```\n\n### element diff \n\n当节点处于同一层级时，React diff 提供了三种节点操作\n\n```js\n// oldDoms是真实DOM，newDoms是最新的虚拟DOM\nconst oldDoms = [A, B, C, D],\n\tnewDoms = [B, A, E, D],\n\tupdates = [],\n\tremoves = [],\n\tcreates = [];\n// 进行两层遍历，获取到哪些节点需要更新，哪些节点需要移除。\nfor (let i = 0; i < oldDoms.length; i++) {\n\tconst oldDom = oldDoms[i]\n\tlet shouldRemove = true\n\tfor (let j = 0; j < newDoms.length; j++) {\n\t\tconst newDom = newDoms[j];\n\t\tif (\n\t\t\t\toldDom.key === newDom.key &&\n\t\t\t\toldDom.type === newDom.type\n\t\t) {\n\t\t\t\tupdates[j] = {\n\t\t\t\t\t\tindex: j,\n\t\t\t\t\t\tnode: oldDom,\n\t\t\t\t\t\tparentNode: parentNode // 这里真实DOM的父节点\n\t\t\t\t}\n\t\t\t\tshouldRemove = false\n\t\t}\n\t}\n\tif (shouldRemove) {\n\t\t\tremoves.push({\n\t\t\t\t\tnode: oldDom\n\t\t\t})\n\t}\n}\n// 从虚拟DOM节点来取出不要更新的节点，这就是需要新创建的节点。\nfor (let j = 0; j < newDoms.length; j++) {\n\tif (!updates[j]) {\n\t\t\tcreates.push({\n\t\t\t\t\tindex: j,\n\t\t\t\t\tvnode: newDoms[j],\n\t\t\t\t\tparentNode: parentNode // 这里真实DOM的父节点\n\t\t\t})\n\t}\n}\n```\n\n* 插入\n\n\t```js\n\tconst create = (creates) => {\n\t\t\tcreates.forEach(create => {\n\t\t\t\t\tconst index = create.index,\n\t\t\t\t\t\t\tparentNode = create.parentNode,\n\t\t\t\t\t\t\tvnode = create.vnode,\n\t\t\t\t\t\t\tcurNode = parentNode.children[index],\n\t\t\t\t\t\t\tnode = createNode(vnode); // 创建DOM节点\n\t\t\t\t\tparentNode.insertBefore(node, curNode)\n\t\t\t})\n\t}\n\t```\n\n* 移动\n\n\t```js\n\tconst update = (updates) => {\n\t\t\tupdates.forEach(update => {\n\t\t\t\t\tconst index = update.index,\n\t\t\t\t\t\t\tparentNode = update.parentNode,\n\t\t\t\t\t\t\tnode = update.node,\n\t\t\t\t\t\t\tcurNode = parentNode.children[index];\n\t\t\t\t\tif (curNode !== node) {\n\t\t\t\t\t\t\tparentNode.insertBefore(node, curNode)\n\t\t\t\t\t}\n\t\t\t})\n\t}\n\t```\n\n* 删除\n\n\t```js\n\tconst remove = (removes) => {\n\t\t\tremoves.forEach(remove => {\n\t\t\t\t\tconst node = remove.node\n\t\t\t\t\tnode.parentNode.removeChild(node)\n\t\t\t})\n\t}\n\t```\n\n### 后续\n\n* 看到这里，我们首先能引出一个思考🤔，那就是 vue 与 React diff 算法的不同\n\t\n\t* react 有 compnent diff，而 vue 没有\n\t\n\t\t> \t在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。\n\t\t> \n\t\t> \t如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。\n\t\t> \n\t\t> \t然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。\n\t\t> \n\t\t> \t在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。\n\t\t> \n\t\t> \tVue 的这个特点使得开发者不再需要考虑此类优化，从而能够更好地专注于应用本身。\n\n\t\t所以说，React 之所以会有 component 的比较，而 vue 在虚拟DOM 为 component 时会跳过 diff ，就是这个原因\n\t\n\t* 剩下的 tree diff 与 element diff 两者都有，虽然具体实现不同，但都是有的\n\n* 其次，我们想这么一种场景🎬，因为 React setState 会更新其组件以及它的所有子组件，这些组件会全部进行 diff 算法对比，那么在存在大量子组件的情况下，这种算法无疑是十分耗费性能的，所以，这也就是 React 团队会耗时两年的时间，将 fiber 引入 React 的原因。\n\n### 参考资料\n\n[react diff简单实现](https://zhuanlan.zhihu.com/p/63964441)\n\n[[译] React性能优化：Virtual Dom原理浅析](https://zhuanlan.zhihu.com/p/36798520)\n\n[React 源码剖析系列 － 不可思议的 react diff](https://zhuanlan.zhihu.com/p/20346379)\n\n[协调](https://zh-hans.reactjs.org/docs/reconciliation.html)\n\n[React源码之Diff算法](https://segmentfault.com/a/1190000010686582)",
      "data": {
        "title": "React diff Essay",
        "date": "2020-03-19 14:19:05",
        "tags": [
          "React",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-diff-essay"
    },
    {
      "content": "### 概要\n\n在之前实现的 Simple Vue 里，我们在模版的 compile 依赖收集时将每个依赖都创建了一个watcher（Vue 1.0），这样是没法撑住大应用的，所以在 2.0 里面每一个组件创建一个 watcher，但问题是这种粒度下我们无法判断组件中那些元素进行了更改，**这时候，我们就需要虚拟DOM了**。\n\n那么有了虚拟DOM后，我们如何进行高效的 DOM 更新呢，**这时候 diff 算法就出现了**。\n\n为了方便我们随时清楚自己在diff算法的哪个流程，我们附上下图\n\n![](https://sfmonkey.github.io//post-images/1584501228011.jpeg)\n\n我们来根据这张图，逐步理解 diff 算法\n\n### patch\n\n* patch 主要接收两个参数， oldVnode 和 Vnode。**因为有较多情况存在直接创建新树的情况，一般也可以理解为 patch 进行的是树级别的比较。**\n\n\t```js\n\tfunction patch() {\n\t\tif (isUndef(oldVnode)) {\n\t\t\t\t// empty mount (likely as component), create new root element\n\t\t\t\tisInitialPatch = true\n\t\t\t\tcreateElm(vnode, insertedVnodeQueue)\n\t\t} else {\n\t\t\tif (sameVnode(oldVnode, vnode)) {\n\t\t\t\tpatchVnode(oldVnode, vnode)\n\t\t\t} else {\n\t\t\t\t...\n\t\t\t\t// create new node\n\t\t\t\tcreateElm(\n\t\t\t\t\tvnode,\n\t\t\t\t\tnodeOps.nextSibling(oldElm)\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\t\n\t\t...\n\t\tremoveVnodes([oldVnode], 0, 0)\n\t}\n\t```\n\n\t1. 如果 oldVnode 不存在，则直接根据 vnode 创建 DOM\n\t2. 如果 oldVnode 与 vnode 不属于 sameVnode，这直接替换,属于 replace 操作\n\t3. 如果属于 sameVnode，那么开始进行节点比较 patchVnode\n\n### sameVnode\n\n* sameVnode 用来判断是否属于相同的节点，其实如果 key，tag，isComment，isDef(data) ，sameInputType相同，就是相同的节点。可以进行 patchVnode 了。\n\n\t```js\n\tfuncton sameVnode(a，b) {\n\t\t\treturn (\n\t\t\ta.key === b.key && (\n\t\t\t\t(\n\t\t\t\t\ta.tag === b.tag &&\n\t\t\t\t\ta.isComment === b.isComment &&\n\t\t\t\t\tisDef(a.data) === isDef(b.data) &&\n\t\t\t\t\tsameInputType(a, b)\n\t\t\t\t)\n\t\t\t\t...\n\t\t)\n\t}\n\t```\n\n\t1. \tkey：key值\n\t2. \ttag：标签名\n\t3. \tisComment 是否为注释节点\n\t4. \tisDef(data)：是否定义了 data\n\t5. \tsameInputType：当标签是 input 的时候，type 必须相同\n\n### patchVnode\n\n* patchVnode 用于进行两个相同节点的比较,然后进行相关DOM操作，操作的类型有三种\n\n\t* 属性更新\n\t\t* 当 data 有定义时，需要进行属性的更新\n\t* 文本更新\n\t\t* 当新老节点都无子节点的时候，只是文本的替换\n\t* 子节点更新\n\t\t* 如果老节点没有子节点而新节点有子节点，先清空DOM的文本内容，然后为 DOM 新增子节点\n\t\t* 如果新节点没有子节点而老节点有子节点，则移除DOM的所有子节点（在外层已经判断新节点没有文本了）\n\t\t* 如果新老节点都存在 children 子节点，则调用 updateChildren，对子节点进行 diff 操作\n\t\n\t```js\n\tfunction patchVnode(odlVnode， vnode) {\n\t\t...\n\t\n\tconst oldCh = oldVnode.children\n\tconst ch = vnode.children\n\t\n\tif (isDef(data) && isPatchable(vnode)) {\n\t\tfor (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n\t\tif (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\n\t}\n\t\n\tif (isUndef(vnode.text)) {\n\t\tif (isDef(oldCh) && isDef(ch)) {\n\t\t\tif (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n\t\t} else if (isDef(ch)) {\n\t\t\tif (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n\t\t\taddVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n\t\t} else if (isDef(oldCh)) {\n\t\t\tremoveVnodes(oldCh, 0, oldCh.length - 1)\n\t\t} else if (isDef(oldVnode.text)) {\n\t\t\tnodeOps.setTextContent(elm, '')\n\t\t}\n\t} else if (oldVnode.text !== vnode.text) {\n\t\tnodeOps.setTextContent(elm, vnode.text)\n\t}\n\t\t...\n\t}\n\t```\n\n### updateChildren\n\n* updateChildren 用于判断新老节点的子节点\n\n\t```js\n\twhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t\tif (isUndef(oldStartVnode)) {\n\t\t\toldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n\t\t} else if (isUndef(oldEndVnode)) {\n\t\t\toldEndVnode = oldCh[--oldEndIdx]\n\t\t} else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t\t\tpatchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n\t\t\toldStartVnode = oldCh[++oldStartIdx]\n\t\t\tnewStartVnode = newCh[++newStartIdx]\n\t\t} else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t\t\tpatchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n\t\t\toldEndVnode = oldCh[--oldEndIdx]\n\t\t\tnewEndVnode = newCh[--newEndIdx]\n\t\t} else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t\t\tpatchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n\t\t\toldStartVnode = oldCh[++oldStartIdx]\n\t\t\tnewEndVnode = newCh[--newEndIdx]\n\t\t} else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t\t\tpatchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n\t\t\toldEndVnode = oldCh[--oldEndIdx]\n\t\t\tnewStartVnode = newCh[++newStartIdx]\n\t\t} else {\n\t\t\tif (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n\t\t\tidxInOld = isDef(newStartVnode.key)\n\t\t\t\t? oldKeyToIdx[newStartVnode.key]\n\t\t\t\t: findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n\t\t\tif (isUndef(idxInOld)) { // New element\n\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n\t\t\t} else {\n\t\t\t\tvnodeToMove = oldCh[idxInOld]\n\t\t\t\tif (sameVnode(vnodeToMove, newStartVnode)) {\n\t\t\t\t\tpatchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n\t\t\t\t\toldCh[idxInOld] = undefined\n\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n\t\t\t\t} else {\n\t\t\t\t\t// same key but different element. treat as new element\n\t\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewStartVnode = newCh[++newStartIdx]\n\t\t}\n\t}\n\t```\n\n\t这里的逻辑稍微有点复杂，在 oldCh 和 ch 中，提供四个指针\n\n\t![](https://sfmonkey.github.io//post-images/1584511735002.jpeg)\n\n* oldCh 和 ch 指针两两进行 sameVnode 比较，共分四种情况\n\t* oldS 和 S 匹配，那么两者进行 patchVnode，匹配上的两个指针向中间移动\n\t* oldE 和 E 匹配，那么两者进行 patchVnode，匹配上的两个指针向中间移动\n\t* oldS 和 E 匹配，那么两者进行 patchVnode，匹配上的两个指针向中间移动，真实 DOM 中的第一个节点会移动到最后\n\t* oldE 和 S 匹配，那么两者进行 patchVnode，匹配上的两个指针向中间移动，真实 DOM 中的最后一个节点会移动到最前\n\n* 如果四种匹配都没有成功，则又分为两种情况\n\n\t* 如果新旧节点都存在key，那么会根据 oldCh 的key 生成一张 hash表，用S的key与 hash匹配，如果匹配成功就判断 S 和匹配节点是否是 sameNode，如果是，就进行 patchVnode，将 DOM 放在 oldS 前面，然后移动 S，否则剩下情况就创建新的 DOM，插入 oldS 的位置，然后 S 指针向中间移动。\n\t* 如果没有key，则直接创建新DOM 插入 oldS 位置\n\n* 当然，在最后，结束条件即 oldS > oldE 或者 S > E 后\n\n\t```js\n\tif (oldStartIdx > oldEndIdx) {\n\t\trefElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n\t\taddVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n\t} else if (newStartIdx > newEndIdx) {\n\t\tremoveVnodes(oldCh, oldStartIdx, oldEndIdx)\n\t}\n\t```\n\t\n\t* 如果 oldStartIdx > oldEndIdx ，那么将 S 与 E 及两者之间的进行 DOM 新增\n\t* 如果 newStartIdx > newEndIdx ，那么将 oldS 与 oldE 及两者之间的进行 DOM 删除\n\n### 参考资料\n[详解vue的diff算法](https://juejin.im/post/5affd01551882542c83301da#heading-6)",
      "data": {
        "title": "Vue diff Essay",
        "date": "2020-03-18 11:00:14",
        "tags": [
          "Vue",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vue-diff-essay"
    },
    {
      "content": "### 概要\n\n和 Vue 一样，在实现 React 之前，我们需要弄清楚 React 到底是什么，这样才方便我们去实现它。\n\n* React 是用于构建用户界面的 JavaScript 库\n\n* React 不是一个完整的 MVC 框架，最多可以认为是 MVC 中的 V（view）\n\n所以我们实现 React 的时候，只需要关注 React 如何处理 UI 就可以了，也就是这三个 api\n\n* createElement\n\n* render\n\n* component\n\n### createElement\n\n* createElement 函数帮助我们生成 vnode（虚拟函数）\n\n\t```js\n\t// react.js\n\tfunction createElement(type, props, ...children) {\n\t\tif (props) {\n\t\t\tdetele props.__source,\n\t\t\tdelete props.__self\n\t\t}\n\t\t\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tprops: {\n\t\t\t\t...props,\n\t\t\t\tchildren: children.map(child => {\n\t\t\t\t\ttypeof child === 'object' ? child : createTextNode(child);\n \t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction createTextNode(text) {\n\t\treturn {\n\t\t\ttype: \"TEXT\",\n\t\t\tprops: {\n\t\t\t\tchildren: [],\n\t\t\t\tnodeValue: text\n\t\t\t}\n\t\t}\n\t}\n\t\n\texport default {\n\t\tcreateElement\n\t}\n\t```\n\t\n### render\n\t\n* 我们再使用 render 函数将 vnode 转换为 node\n\n\t```js\n\t// react-dom.js\n\tfunction render (vnode, container) {\n\t\tconst node = createNode(vnode);\n\n\t\tcontainer.appendChild(node);\n\t}\n\n\tfunction createNode(vnode) {\n\t\tconst {type, props} = vnode;\n\t\tlet node;\n\n\t\tif (typeof type === 'function') {\n\t\t\tnode = type.isReactComponent ? updateClassComponent(vnode) : updateFunctionComponent(vnode)\n\t\t} else if (type === 'TEXT') {\n\t\t\tnode = document.createTextNode(\"\");\n\t\t} else if (type) {\n\t\t\tnode = document.createElement(type);\n\t\t} else {\n\t\t\tnode = document.createDocumentFragment();\n\t\t}\n\t\tupdateNode(node, props);\n\t\treconcilerChildren(props.children, node);\n\n\t\treturn node;\n\t}\n\n\tfunction updateNode(node, props) {\n\t\tObject.keys(props)\n\t\t\t.filter(k => k !== 'children')\n\t\t\t.forEach(k => {\n\t\t\t\tif (k.slice(0,2) === 'on') {\n\t\t\t\t\tlet eventName = k.slice(2).toLocaleLowserCase();\n\t\t\t\t\tnode.addEventListener(eventName, props[K]);\n\t\t\t\t} else {\n\t\t\t\t\tnode[k] = props[k];\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tfunction reconcilerChildren(children, node) {\n\t\tfor (let i =0; i < children.length, i++) {\n\t\t\tlet child = children[i];\n\n\t\t\tif (Array.isArray(child)) {\n\t\t\t\tfor (let i =0; i < child.length, i++){\n\t\t\t\t\trender(child[i], node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trender(child, node);\n\t\t\t}\n\t\t}\n\t}\n\n\texport default {\n\t\trender\n\t}\n\t```\n\n* 需要对 type 类型进行判断，根据不同的 type 创建不同的元素，比较特殊的是函数组件和 Class 组件\n\n\t```js\n\tfunction updateClassComponent(vnode) {\n\t\tconst {type, props} = vnode;\n\t\tconst cmp = new type(props);\n\t\tconst vvnode = cmp.render();\n\t\tconst node = createNode(vvnode);\n\n\t\treturn node;\n\t}\n\n\tfunction updateFunctionComponent(vnode) {\n\t\tconst {type, props} = vnode;\n\t\tconst vvnode = type(props);\n\t\tconst node = createNode(vvnode);\n\n\t\treturn node;\n\t}\n\t```\n\t\n### component\n\n* 上面用到的 isReactComponent 属性就是在 Component 中定义的\n\n\t```js\n\texport default class Component {\n\t\tstatic isReactComponent  = {};\n\t\tconstructor(props) {\n\t\t\tthis.props = props;\n\t\t}\n\t}\n\t```\n\n* 其实，如果用上面的方式实现一个时钟，我们只能每次都删除原来的所有节点并重新创建\n\n\t```js\n\tconst rootDom = document.getElementById(\"root\");\n\n\tfunction tick() {\n\t\tconst time = new Date().toLocaleTimeString();\n\t\tconst clockElement = <h1>{time}</h1>;\n\t\trender(clockElement, rootDom);\n\t}\n\n\ttick();\n\tsetInterval(tick, 1000);\n\t```\n\n\t很明显的，这个在性能上是不可接受的，所以我们需要 diff 算法，这个不在本文讨论。\n\n\n### 总结\n\n1. babel 将 jsx 转换为 cleateElement\n2. cleateElement 函数得到 vnode\n3. render 函数将 vnode 转换为 node\n\n\n\n\n\n",
      "data": {
        "title": "Simple React Essay",
        "date": "2020-03-16 11:20:13",
        "tags": [
          "React",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/simple-react-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "simple-react-essay"
    },
    {
      "content": "### 概要\n\n在实现 Vue 之前，我们先要清楚 Vue 的概念，真正的知道它是什么，然后才能知道怎么去实现。\n\n* Vue 是一套用于构建用户界面（UI）的渐进式框架，它的核心库只关注视图层。\n\n* Vue 是一个 MVVM 框架。\n\n\t实现 MVVM 主要有三个核心点：\n\n\t* 数据响应式：监听数据变化并在视图中更新\n\n\t\t* Object.defineProperty()\n\t\t\n\t\t* Proxy\n\t\n\t* 模版引擎：提供描述视图的模版语法\n\n\t\t* 插值：{{}}\n\n\t\t* 指令：v-bind，v-on，v-model，v-for，v-if\n\n\t* 模版渲染：如何将模版转换为 html\n\n\t\t* 模版 -> vdom -> dom\n\n\t所以，如果我们去实现，可以从 MVVM 结构，三个核心点去着力实现。\n\t\n### 数据响应式\n\n这里我们只讲 defineProperty 实现的数据响应式。\n\n* 首先我们需要一个函数，去帮助我们给数据赋予响应式的能力\n\n\t```js\n\tfunction defineReactive(obj,key,val) {\n\t\tObject.defineProperty(obj, key, {\n\t\t\tget() {\n\t\t\t\tconsole.log(`get ${key}:${val}`);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tset(newVal) {\n\t\t\t\tif (newVal !== val) {\n\t\t\t\t\tconsole.log(`set ${key}:${newVal}`);\n\t\t\t\t\tval = newVal;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t```\n\t\n* 当我们结合视图时，我们就需要一个更新函数了\n\n\t```html\n\t<html>\n\t\t<head></head>\n\t\t<body>\n\t\t\t<div id=\"app\"></div>\n\t\t\t<script>\n\t\t\t\t\tfunction defineReactive(obj,key,val) {\n\t\t\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\t\tconsole.log(`get ${key}:${val}`);\n\t\t\t\t\t\t\t\treturn val;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tset(newVal) {\n\t\t\t\t\t\t\t\tif (newVal !== val) {\n\t\t\t\t\t\t\t\t\tconsole.log(`set ${key}:${newVal}`);\n\t\t\t\t\t\t\t\t\tval = newVal;\n\t\t\t\t\t\t\t\t\tupdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst obj = {};\n\t\t\t\t\tdefineReactive(obj, 'foo', '');\n\t\t\t\t\tobj.foo = new Date().toLocaleTimeString();\n\t\t\t\t\n\t\t\t\t\t//! 更新函数\n\t\t\t\t\tfunction update(val) {\n\t\t\t\t\t\tapp.innerText = obj.foo;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tsetInterval(() => {\n\t\t\t\t\t\tobj.foo = new Date().toLocaleTimeString();\n\t\t\t\t\t}, 1000);\n\t\t\t</script>\n\t\t</body>\n\t</html>\n\t```\n\n* 当然，用户不可能只传入一个属性，我们需要对传入的数据进行遍历\n\n\t```js\n\tfunction observe(obj) {\n\t\t// 当传入的数据不是对象或者为空时，返回\n\t\tif (typeof obj !== 'object' || obj == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tObject.keys().forEach(key= > defineReactive(obj, key, obj[key]));\n\t}\n\n\tfunction defineReactive(obj,key,val) {\n\t\tobserve(val); //! val 是对象的情况\n\t\tObject.defineProperty(obj, key, {\n\t\t\tget() {\n\t\t\t\tconsole.log(`get ${key}:${val}`);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tset(newVal) {\n\t\t\t\tif (newVal !== val) {\n\t\t\t\t\tconsole.log(`set ${key}:${newVal}`);\n\t\t\t\t\tobserve(newVal)//! 赋值是对象的情况\n\t\t\t\t\tval = newVal;\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t```\n\t\n* 还有一种情况，就是我们给对象添加新的属性,这时候，我们需要手动为其赋予响应式能力\n\n\t```js\n\tfunction set(obj, key, val) {\n\t\tdefineReactive(obj, key, val)\n\t}\n\t```\n\n### 模版引擎以及渲染\n\n* 这里我们不去考虑如何实现模版引擎，以及 模版-> vnode -> dom 的过程中 vnode 的部分，只考虑 模版 -> dom。\n\n\t```js\n\tclass Compile {\n\t\tconstructor(el, vm) {\n\t\t\tthis.$vm = vm;\n\t\t\tthis.$el = document.querySelector(el);\n\n\t\t\tif (this.$el) {\n\t\t\t\tthis.compile(this.$el);\n\t\t\t}\n\t\t}\n\n\t\tcompile(el) {\n\t\t\tconst childNodes = el.childNodes;\n\n\t\t\tArray.from(childNodes).forEach(node => {\n\t\t\t\tif (this.isElement(node)) {\n\t\t\t\t\tthis.compileElement(node);\n\t\t\t\t} else if (this.isInterpolation(node)) {\n\t\t\t\t\tthis.compileText(node);\n\t\t\t\t}\n\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0) {\n\t\t\t\t\tthis.compile(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t```\n\t\n* 关于 isElement，isInterpolation, compileElement, compileText 函数\n\n\t```js\n\tfunction isElement(node) {\n\t\treturn node.nodeType === 1;\n\t}\n\n\tfunction isInterpolation(node) {\n\t\treturn node.nodeType === 3 && /\\{\\{(.*)\\}\\}/.test(node.textContent);\n\t}\n\n\tfunction compileElement(node) {\n\t\tlet nodeAttrs = node.attributes;\n\t\tArray.from(nodeAttrs).forEach(attr => {\n\t\t\tlet name = attr.name;\n\t\t\tlet value = attr.value;\n\t\t\tif (this.isDirective(name)) {\n\t\t\t\tlet dir = name.substring(2);\n\t\t\t\tthis[dir] && this[dir](node, value)\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction compileText(node) {\n\t\tnode.textContent = this.$vm[RegExp.$1]\n\t}\n\n\tfunction isDirective(attr) {\n\t\treturn attr.indexOf(\"k-\") === 0\n\t}\n\t```\n\t\n* 当然，指令就很多，我们简单写两个\n\n\t```js\n\tfunction text(node, value) {\n\t\tnode.textContent = this.$vm[value];\n\t}\n\tfunction html(node, value) {\n\t\tnode.innerHTML = this.$vm[value];\n\t}\n\t```\n\n* 在 compile 的过程中，我们需要进行依赖收集，这里我们实现的是 Vue1.0 时候的依赖收集，一个依赖一个watcher，一个数据响应式的 Key 一个 Dep\n\t\n\t*  watcher 类\n\t\n\t\t```js\n\t\t// watcher\n\t\tclass watcher {\n\t\t\tconstructor(vm, key, updateFn) {\n\t\t\t\tthis.vm = vm;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.updateFn = updateFn;\n\n\t\t\t\t// 订阅到 dep\n\t\t\t\tDep.target = this;\n\t\t\t\tthis.vm[this.key];\n\t\t\t\tDep.target = null;\n\t\t\t}\n\n\t\t\tupdate() {\n\t\t\t\tthis.updateFn.call(this.vm, this.vm[this.key]);\n\t\t\t}\n\t\t}\n\t\t```\n\t\n\t* 在生成 dom 时订阅 watcher\n\t\n\t\t```js\n\t\tcompileText(node) {\n\t\t\tthis.update(node, RegExp.$1, 'text');\n\t\t}\n\n\t\tupdate(node, exp, 'text') {\n\t\t\tconst fn = this[dir + 'Updater']\n\t\t\tfn && fn(node, this.vm[exp])\n\n\t\t\tnew watcher(this.vm, exp, function(val) {\n\t\t\t\tfn && fn(node, val)\n\t\t\t})\n\t\t}\n\t\t```\n\t\n\t* Dep 类\n\t\n\t\t```js\n\t\t//Dep\n\t\tclass Dep {\n\t\t\tconstructor() {\n\t\t\t\tthis.deps = []\n\t\t\t}\n\n\t\t\taddDep(watcher) {\n\t\t\t\tthis.deps.push(watcher);\n\t\t\t}\n\n\t\t\tnotify() {\n\t\t\t\tthis.deps.forEach(watcher => watcher.update());\n\t\t\t}\n\t\t}\n\t\t```\n\n\t* 在数据响应式时，实例化 Dep\n\n\t```js\n\tdefineReactive() {\n\t\t...\n\t\t\n\t\tconst dep = new Dep();\n\t\t\n\t\tObject.defineProperty(obj, key, {\n\t\t\tget() {\n\t\t\t\tDep.target && dep.addDep(Dep.target);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tset(newVal) {\n\t\t\t\tif (newVal !== val) {\n\t\t\t\t\tobserve(newVal)//! 赋值是对象的情况\n\t\t\t\t\tval = newVal;\n\t\t\t\t\tdep.notify();\n\t\t\t\t}\n\t\t\t}\n\t}\n\t```\n\t\n### 总结\n\n1. \tdefineReactive 为每一个 key 创建一个 dep\n2. \t初始化视图的时候读取某个数据，创建一个watcher\n3. \t由于在watcher中读取了key，便将 watcher 订阅到了 dep 中\n4. \t当某个key更新时，触发setter，相关dep 通知所有watcher更新\n\n\t![](https://sfmonkey.github.io//post-images/1584324343056.jpg)\n\n\n\t\n\n",
      "data": {
        "title": "Simple Vue Essay",
        "date": "2020-03-13 10:05:16",
        "tags": [
          "Vue",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/simple-vue-essay.jpeg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "simple-vue-essay"
    },
    {
      "content": "### 概要\n\n* vuex **集中式**存储管理应用的所有组件的状态，并以相应的规则保证状态以**可预测**的方式发生变化。\n\n\t> \tvuex 与 vue-router 因为都采用 vue 的响应式机制来实现了对应 view 层的更新，所以两个都依赖 vue 才能使用\n\n* 核心概念\n\t* state 状态数据\n\t* mutations 更改状态的函数，commit 触发\n\t* actions 异步操作，dispatch 触发\n\t* store 包含以上概念的容器\n\n### 插件机制\n\n* 这个之前 vue-router 写过，直接上代码\n\n\t```js\n\tconst install = (_vue) => {\n\t\tlet vue = _vue;\n\n\t\tvue.mixin({\n\t\t\tbeforeCreate() {\n\t\t\t\tif (this.$options.store) {\n\t\t\t\t\tvue.prototype.$store = this.$options.store;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif (type window === 'object' && window.vue) {\n\t\tinstall(window.vue);\n\t}\n\t```\n\n### state\n\n* 使用\n\n\t```js\n\t// store.js\n\texport default new Vuex.store({\n\t\tstate: {counter: 0}\n\t});\n\t\n\t// page.vue\n\tconsole.log(this.$store.state.counter)\n\t```\n\t\n* 实现\n\n\t```js\n\tclass Store {\n\t\tconstructor(options = {}){\n\t\t\tthis._vm = new Vue({\n\t\t\t\tdata: {\n\t\t\t\t\t$$state: options.state\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tget state() {\n\t\t\treturn this._vm._data.$$state\n\t\t}\n\n\t\tset state(v) {\n\t\t\tconsole.error('you can not set state immediately');\n\t\t}\n\t}\n\t```\n\n### mutations\n\n* 使用\n\n\t```js\n\texport default new vuex.store({\n\t\tmutations: {\n\t\t\tadd(state,payload) {\n\t\t\t\tstate.counter ++\n\t\t\t}\n\t\t}\n\t});\n\t```\n\n* 实现\n\n\t```js\n\tclass Store {\n\t\tconstructor(options = {}) {\n\t\t\tthis._mutations = options.mutations || {};\n\t\t}\n\n\t\tcommit(type, payload) {\n\t\t\tconst entry = this._mutations[type];\n\n\t\t\tif (!entry) {\n\t\t\t\tconsole.error(`unknown mutation type: ${type}`);\n\t\t\t\treturn ;\n\t\t\t}\n\n\t\t\tentry(this.state, payload);\n\t\t}\n\t}\n\t```\n\n### actions\n\n* 使用\n\n\t```js\n\texport default new vuex.Store({\n\t\tactions: {\n\t\t\tadd({commit}, payload) {\n\t\t\t\tsetTimeout(()=> {\n\t\t\t\t\tcommit('add');\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\t});\n\t```\n\n* 实现\n\n\t```js\n\tclass Store {\n\t\tconstructor(options = {}) {\n\t\t\tthis._actions = options.actions || {}\n\n\t\t\tthis.commit = this.commit.bind(this);\n\t\t\tthis.action = this.action.bind(this);\n\t\t}\n\n\t\tdispatch(type, payload) {\n\t\t\tconst entry = this._actions[type];\n\n\t\t\tif (!entry) {\n\t\t\t\tconsole.error(`unknown action type: ${type}`);\n\t\t\t\treturn ;\n\t\t\t}\n\n\t\t\treturn entry(this, payload);\n\t\t}\n\t}\n\t```\n\t\n### getters\n\n* 使用\n\n\t```js\n\texport default new vuex.Store({\n\t\tgetters: {\n\t\t\tdoubleCounter(state) {\n\t\t\t\treturn state.counter * 2;\n\t\t\t}\n\t\t}\n\t});\n\t```\n\n* 实现\n\n\t```js\n\tclass Store {\n\t\tconstructor(options = {}) {\n\t\t\tconst _getters = options.getters || {}\n\t\t\tthis._vm = new vue({\n\t\t\t\tcomputed: _getters\n\t\t\t});\n\n\t\t\tfor(key in _getters) {\n\t\t\t\tObject.defineProperty(this.getters, key, {\n\t\t\t\t\tget: () => this._vm[key],\n\t\t\t\t\tenumerable: true // for local getters\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\t```\n\n\n\n",
      "data": {
        "title": "Vuex Essay",
        "date": "2020-03-11 14:24:36",
        "tags": [
          "Vue",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/vuex-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vuex-essay"
    },
    {
      "content": "### 概要\n\nReact-redux 是 React 的状态应用，可以保证数据的一致性且易于追溯和测试。关于 React-redux，前置知识有：\n\n* context\n* redux\n\n接着才是主菜\n\n* react-redux\n\n### Context\n\n这里的 Context 指的是 React 的上下文，属于 React 的高级部分，虽然官方认为一个稳定的 React 应用不应该使用 Context，但是许多的优秀的 React 库都使用了 Context，比如 React-router 以及 React-redux。\n\nContext 的 API 有三个 (hooks 相关的这里不做讨论)\n\n* CreateContext （可以理解为种菜的）\n\n\t```js\n\t// 参数可以接收初始值\n\tconst UserContext = React.CreateContext({name: \"potter\"});\n\t```\n\n* Provider （可以理解为收菜的供货商）\n\n\t```js\n\tconst UserProvider = UserContext.Provider;\n\t```\n\n\t使用方式：\n\n\t```jsx\n\trender() {\n\t\treturn <UserProvider></UserProvider>\n\t}\n\t```\n\n* Cosumer （可以理解为消费者）\n\n\t```js\n\tconst UserCosumer = UserContext.Cosumer;\n\t```\n\n\t使用方式：\n\n\t```jsx\n\trender() {\n\t\treturn <UserCosumer>{\n\t\t\tcontext => {}\n\t\t}</UserCosumer>\n\t}\n\t```\n\n\t这里接收 Context 还有另外一种方式，即在 Class 组件中\n\n\t```js\n\t// 这种接收方式只能获取单一 Context，通过 this.context 获取传递内容\n\tClass User extend Component {\n\t\tstatic contextType = UserContext\n\t}\n\t```\n\t\n### Redux\n\nRedux 是 Js 应用的状态容器。\n\t\n* 使用方式\n\n\tredux 在使用时，大概分为以下几步：\n\n\t* reducer 纯函数制定修改规则\n\t* createStore 创建 store\n\t* store.getState 得到数据\n\t* store.dispatch 更改数据\n\t* store.subscribe 订阅数据改动\n\n* 实现\n\n\t* redux 的实现主要考虑的是 createStore ， 返回的 store 中包含剩下的 getState，dispath 与 subscribe。\n\n\t```js\n\tconst createStore = (reducer, enhancer) => {\n\t\t\n\t\tif(enhancer) { // 这里是判断是否有 redux 中间件，如果有，将 createStore 与 reducer 传入\n\t\t\treturn enhancer(createStore)(reducer)\n\t\t}\n\t\t\n\t\tlet currentState;\n\t\tlet currentListener = [];\n\t\t\n\t\tfunction getStore() {\n\t\t\treturn currentState;\n\t\t}\n\t\t\n\t\tfunction  dispatch(action) {\n\t\t\tconst currentState = reducer(currentState, action);\n\t\t\tcurrentListener.forEach( v=> v());\n\t\t}\n\t\t\n\t\tfunction subscribe(v) {\n\t\t\tcurrentListener.push(v);\n\t\t}\n\t\t\n\t\t// 处理初始值的情况\n\t\tdispatch({type: '@@INIT'});\n\t\t\n\t\treturn {\n\t\t\tgetState,\n\t\t\tdispatch,\n\t\t\tsubscribe\n\t\t}\n\t}\n\t```\n\t\n\t* redux 只是一个纯粹的状态管理器，默认只支持同步，我们需要通过中间件来支持异步。所有的中间件都是一个函数，通过对 dispatch 的改造，在 action 与 reducer 之间，添加了其他的功能。\n\n\t\t这里我们需要做两件事：\n\t\t\n\t\t* createStore 增加 enhancer 参数，增加 applyMiddleware 函数\n\n\t\t```js\n\t\tconst applyMiddleware = (...middlewares) => {\n\t\t\treturn createStore => （...args）=> {\n\t\t\t\tconst store = createStore(...args);\n\t\t\t\tconst middleApi = {\n\t\t\t\t\tgetState: store.getState,\n\t\t\t\t\tdispatch: store.dispatch\n\t\t\t\t};\n\t\t\t\tconst middlewaresChain = middlewares.map(middleware => middleware(middleApi))\n\t\t\t\t\n\t\t\t\tlet dispatch = compose(middlewaresChain)(store.dispatch);\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\t...store,\n\t\t\t\t\tdispatch\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t```\n\t\t\n\t\t这里面还涉及到一个 compose 函数\n\t\t\n\t\t```js\n\t\tconst compose = (...funs) => {\n\t\t\tif (funs.length === 0) {\n\t\t\t\treturn arg => arg;\n\t\t\t}\n\t\t\tif (funs.length === 1) {\n\t\t\t\treturn funs[0];\n\t\t\t}\n\t\t\t\n\t\t\treturn funs.reduce((a,b) => (...args) => a(b(...args)));\n\t\t}\n\t\t```\n\n\t\t* 外部其他库实现 redux-thunk ， redux-logger 等中间件\n\n\t\t```js\n\t\t// redux-thunk\n\t\tfunction thunk({dispatch, getState}) {\n\t\t\treturn dispatch  => action => {\n\t\t\t\tif (typeof action === \"function\") {\n\t\t\t\t\treturn action(dispatch, getState);\n\t\t\t\t} else {\n\t\t\t\t\treturn dispatch(action)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// redux-logger\n\t\tfunction logger() {\n\t\t\treturn dispath => action => {\n\t\t\t\tconsole.log(action.type + '执行了');\n\t\t\t\treturn dispatch(action);\n\t\t\t}\n\t\t}\n\t\t```\n\t\t\n### react-redux\n\n* 出现原因\n\n\tRedux 和 React 一起用的时候有两个不太完美的地方\n\n\t* store 每个组件都需要引入\n\t* 每次都需要调用订阅函数，在里面触发 render\n\n  React-redux 帮助我们解决了这两个痛点，提供了两个 API\n\n\t* Provider 为后代组件提供 store\n\t* connect 为组件提供数据和变更方法\n\n* 使用\n\n\t* Provider\n\n\t```js\n\t//一般放在根组件外层，方便后代组件调用\n\tReactDOM.render(\n\t<Provider store={store}>\n\t\t<App/>\n\t</Provider>,\n\tdocument.getElementById('root')\n\t);\n\t```\n\t\n\t* connect\n\n\t```js\n\texport default connect(\n\t\t// mapStateToProps Function (state, ownProps)\n\t\t// ! ownProps 需要谨慎使用，如果它发生变化，mapStateToProps 就会执行，里面的 state 会被重新计算\n\t\t// ! 容易影响性能\n\t\tstate => ({num: state.num}),\n\t\t\n\t\t// mapDispatchToProps Object/Function/undefined \n\t\t// ! 如果不定义，默认把 dispatch 注入组件\n\t\t// ! 如果是对象的话，原版的 dispatch 就没有被注入了\n\t\t{\n\t\t\tadd: () => ({type: 'ADD'})\n\t\t},\n\t\t// ! 如果是Function (dispatch, ownProps) 的话，同样谨慎使用 ownProps\n\t\t(dispatch) => {\n\t\t\tlet res = {add: ()=> ({type: 'ADD'}), minus: ()=> ({type: 'MINUS'})};\n\t\t\t\n\t\t\t// bindActionCreators 可以帮助我们用 dispatch 对 action creator 进行包装\n\t\t\tres = bindActionCreators(res, dispatch);\n\t\t\t\n\t\t\treturn {dispatch, ...res}\n\t\t}\n\t\t\n\t\t// mergeProps Function (mapStateToProps, mapDispatchToProps, ownProps)\n\t\t// ! mapStateToProps, mapDispatchToProps 的执行结果，以及组件自身的 prop 都将作为参数传入这个函数\n\t\t(mapStateToProps,mapDispatchToProps,ownProps) => {\n\t\t\treturn {omg:\"omg\",...mapStateToProps,...mapDispatchToProps,...ownProps}\n\t\t}\n\t\t\n\t)(<SomePage></SomePage>);\n\t```\n\n*  实现\n\n\t* Provider\n\n\t```js\n\tclass Provider extends Component {\n\t\trender () {\n\t\t\treturn <ValueContext.Provider value={this.props.store}>{this.props.children}</ValueContext.Provider>\n\t\t}\n\t}\n\t```\n\t\n\t* connect\n\n\t```js\n\tconst connect = (mapStateToProps = state =>state , mapDispatchToProps) => WrappedComponent => {\n\t\treturn class extends Component {\n\t\t\tstatic contextType = ValueContext;\n\t\t\tconstructor(props) {\n\t\t\t\tsuper(props);\n\t\t\t\tthis.state = {\n\t\t\t\t\tprops: {}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcomponentDidMount() {\n\t\t\t\tthis.update();\n\t\t\t\tconst {subscribe} = this.context;\n\t\t\t\tsubscribe(() => {\n\t\t\t\t\tthis.update();\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tupdate() {\n\t\t\t\tconst {getState, dispatch} = this.context;\n\t\t\t\t\n\t\t\t\tconst stateProps = mapStateToProps(getState());\n\t\t\t\tlet dispatchProps;\n\t\t\t\tif (typeof mapDispatchToProps === 'object') {\n\t\t\t\t\tdispatchProps = bindActionCreators(mapDispatchToProps, dispatch);\n\t\t\t\t}else if (typeof mapDispatchToProps === 'function') {\n\t\t\t\t\tdispatchProps = mapDispatchToProps(dispatch, this.props);\n\t\t\t\t}else {\n\t\t\t\t\tdispatchProps = {dispatch};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.setState({\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...stateProps,\n\t\t\t\t\t\t...dispatchProps\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn <WrappedComponent {...this.props} {...this.state.props}></WrappedComponent>\n\t\t}\n\t}\n\t```\n\t\n\t* bindActionCreators\n\n\t```js\n\tconst bindActionCreator = (creator, dispatch) => {\n\t\treturn (...args) => dispatch(creator(...args));\n\t}\n\n\tconst bindActionCreators = (creators, dispatch) => {\n\t\tconst obj = {};\n\t\tfor(const key in creators){\n\t\t\tobj[key] = bindActionCreator(creators[key], dispatch)\n\t\t}\n\t\treturn obj;\n\t}\n\t```\n\n\n\n\t\n\t\n\t\n\t\n\t",
      "data": {
        "title": "React-redux Essay",
        "date": "2020-03-10 11:58:34",
        "tags": [
          "React",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/react-redux-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-redux-essay"
    },
    {
      "content": "### 概要\n\nVue Router 的实现大致分为三个部分\n\n* 插件机制\n* router-link\n* router-view\n\nVue Router 一共有三种模式， hash（默认），history 以及 abstract（支持 Nodejs 运行环境） ，我们这里暂且只谈 hash 模式。\n\n### 插件机制\n\nVue Router 是作为**插件**的形式接入到 Vue 中的，所以我们在实现 Vue Router 的具体功能前，需要先实现 Vue 插件机制。\n\n* 插件主要的我们需要实现一个 install 函数\n\n\t```js\n\texport const install = () => {\n\t\tVue.mixin({\n\t\t\tbeforeCreate() {\n\t\t\t\tif (this.$options.router) {\n\t\t\t\t\tVue.prototype.$router = this.$options.router;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tVue.component('RouterView', RouterView);\n\t\tVue.component('RouterLink', RouterLink);\n\t}\n\t```\n\t\n\t> \t这里之所以要混入一个 beforeCreate ，是想要判断一下 new Vue 时是否添加了 Router 实例，从而添加全局 Router 实例\n\t\n* 当然为了应对 Vue 可能 Script 标签引入的方式，我们还需要判断处理下这种情况\n\n\t```js\n\tif (typeof window !== undefined && window.vue) {\n\t\tinstall(window.vue);\n\t}\n\t```\n\t\n### router-link\n\n* **Router-LInk** 底层其实也就是个 a 标签，因为是 hash 模式，to 属性我们会直接传给 a 标签的 href。\n\n* 核心代码如下\n\n\t```js\n\tvue.component('RouterLink', {\n\t\tprops: {\n\t\t\t\tto: String, // 还可能是 Object\n\t\t\t\trequired: true\n\t\t},\n\t\t//这里不能使用 template ，因为我们引入的 Vue 一般是 runtime 版本，没有 compiler，无法解析 template\n\t\t//因为这里是个js文件，如果是 vue 文件的话，vue-loader 还可以帮助我们解析 template\n\t\trender(h) { \n\t\t\treturn h('a', {attrs: {href: this.to}}, this.$slots.default);\n\t\t}\n\t});\n\t```\n\t\n### router-view\n\n* **router-view** 是帮助我们根据路由进行选择性展示 UI 的组件。\n\n\n* 因为 Vue Router 是根据 routes 表来进行路由配置的，我们需要根据当前的 hash 来与路由表进行匹配。\n\n\t```js\n\t// VueRouter.js\n\tmatch(routes) {\n\t\troutes = routes || this.$options.routes;\n\n\t\tfor (const route of routes) {\n\t\t\tif (route.path === \"/\" && this.current === \"/\") {\n\t\t\t\tthis.matched.push(route);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (route.path !== \"/\" && this.current.indexOf(route.path) !== -1) {\n\t\t\t\tthis.matched.push(route);\n\t\t\t\tif (route.children) {\n\t\t\t\t\tthis.match(route.children);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t```\n\t\n\t> \t之所以用数组来存储匹配的路由，是因为嵌套路由的存在\n\n* 同样是嵌套路由的关系，我们需要一个 depth 变量，来帮助我们找到对应的子路由\n\n\t```js\n\texport default {\n\t\trender () {\n\t\t\t// 标记该组件是否为 Router View 组件\n\t\t\tthis.$vode.data.routerView = true\n\n\t\t\tlet depth = 0;\n\t\t\t\n\t\t\tconst parent = this.$parent;\n\t\t\twhile(parent) {\n\t\t\t\tconst vnodeData = parent.$vnode && parent.$vnode.data;\n\t\t\t\tif (vnodeData && vnodeData.routerView) {\n\t\t\t\t\tdepth++\n\t\t\t\t}\n\t\t\t\tparent = parent.$parent;\n\t\t\t}\n\t\n\t\t\tlet component = null;\n\t\t\tconst route = this.$router.matched[depth];\n\t\t\n\t\t\tif (route) {\n\t\t\t\tcomponent = route.component;\n\t\t\t}\n\n\t\t\treturn h(component);\n\t\t}\t\t\n\t}\n\t```\n\t\n* 如果 match 有了变化，我们就通知视图重新渲染，这就需要 match 是一个响应式数据\n\n\t```\n\t// VueRouter.js\n\tVue.until.defineReactive(this, 'matched', []);\n\t```\n\n\n\n\n\n",
      "data": {
        "title": "Vue Router Essay",
        "date": "2020-03-09 08:44:00",
        "tags": [
          "Vue",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/vue-router-essay.jpeg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vue-router-essay"
    },
    {
      "content": "### 概要\n\n关于 [react-router](http://react-router.docschina.org/) 我们最常用的 API 有：\n\n* Router\n* Link\n* Route\n* Switch\n* Redirect\n\n这五个 API 基本就可以帮助我们构建一个基础的前端路由系统了\n\n### Router\n\n* 其中 Router 分为 BrowserRouter，HashRouter 以及 MemoryRouter 三种。\n\n\t**BrowserRouter** 是官方最为推荐的一种方式，它的优点在于 URL 地址按照路径划分，较为简洁与美观，使用 HTML5 history API 来保持页面的UI与URL同步。缺点在于 BrowserRouter 需要后端的支持，因为按照路径划分，就会导致用户可能直接访问某一路径，这就需要服务端有相应的路由支持。\n\n\t**HashRouter** 的优点在于简单方便，它利用浏览器 URL Hash 来区分页面 path，不需要后端的支持。缺点在于 Hash Router 不管在 URL 的简洁性，location.key，location.state的支持，动态路由以及其他问题（hash 是没法传给后端的，其他页面拼接参数也需要注意）上，都没有 BrowserRouter 好用。\n\n\t**MemoryRouter** 将 location 的改变放在内存中，我们在 URL 上是没有看到变化的，这在测试或非浏览器环境下非常适用，比如 RN。\n\n* 这里只记录下 BrowserRouter 的实现\n\n\t我们需要明白 BrowserRouter 需要提供的功能是什么\n\n\t* 没得说，展示 children\n\n\t\t```js\n\t\treturn this.props.chilren\n\t\t```\n\n\t* 提供一个context，将 history，location 传递下去\n\n\t\t```jsx\n\t\t<RouterContext value={{history: this.history, location: this.state.location}}></RouterContext>\n\t\t```\n\n### Link\n\n* Link API 分为 Link，NavLink 两种\n\n\t**Link** 帮助我们提供声明式的，可访问的导航。\n\n\t**NavLink** 是 Link 的一种特殊版本，在与 URL 相匹配时，给渲染元素提供一些样式。\n\n* 这里我们想一下 Link 的实现\n\n\t* 本质上还是 a 标签\n\n\t```js\n\t<a onClick={handleClick}>{this.props.children}</a>\n\t```\n\t\n\t* 提供跳转功能\n\n\t当然我们不能使用原生的 href 属性了，因为会导致页面的刷新，我们需要使用 HTML history API 来帮助我们实现路由跳转\n\n\t\t```js\n\t\thandleClick(e, history) {\n\t\t\te.preventDefault();\n\t\t\tconst {to} = this.props;\n\t\t\thistory.push(to);\n\t\t}\n\t\t```\n\t\t\n### Route\n\n* **Route** 组件是 React Router 中最重要的组件，它的作用是在 location 与 Route 的 path 匹配时呈现一些 UI。\n\n* 我们来想一下实现，它都提供了那些功能\n\t\n\t* path 属性，我们在内部判断 path 与 location 是否 match ，来显示对应的 UI\n\n\t```js\n\tconst match = matchPath(location.path, {...this.props, path});\n\t```\n\t\n\t* Route 的 UI 呈现，一共有三种方式：children > component > render\n\t\n\t\t* 如果 match 到了，那么就展示 children， component ，render 或者 null\n\t\n\t\t* 如果没有match到，那么就展示 children 或者 null\n\t\n\t\t```js\n\t\tmatch\n\t\t\t\t? children\n\t\t\t\t\t? typeof children === 'function'\n\t\t\t\t\t\t? children(props)\n\t\t\t\t\t\t: children\n\t\t\t\t\t: component\n\t\t\t\t\t ? React.createElement(component, props)\n\t\t\t\t\t\t: render\n\t\t\t\t\t\t\t? render(props)\n\t\t\t\t\t\t\t: null\n\t\t\t\t: typeof children === 'function'\n\t\t\t\t\t? children(props)\n\t\t\t\t\t: null\n\t\t```\n\n\t* Route 可能会传入一个 location 属性，这时候就会首先使用传入的，而不是 URL 的。\n\n### Switch\n\t\t\n * **Switch** 即独占路由，渲染与 location 匹配的第一个子节点\n \n * 实现的大体思路\n\n\t* 拿到所有的子节点进行遍历，需要一个变量来记录是否已经有匹配的节点\n\n\t```js\n\tReact.children.forEach(children, (child)=> {\n\t\tif (match === null && React.isVaildElement) {\n\t\tmatch = path ? matchPath(location.pathname, child.props) : context.match\n\t})\n\treturn match ? React.cloneElement(child, {location, computedMatch: match}) : null;\n\t```\n\t* 如果找到了 location 与 path 相匹配的路由，就将它渲染出来，否则返回 null\n\t \n### Redirect\n\n* **Redirect**将URL导航到一个新的地址\n\n* 实现的大体思路：\n\n\t* 接受 to 属性，利用 history API 将地址压入栈内\n\n\t```js\n\trender() {\n\t\tconst {to} = this.props;\n\t\treturn <RouterContext>{\n\t\tcontext => {\n\t\t\tconst {history} = context;\n\t\t\treutrn <LifeCycle isMounted={(history)=>{history.push(to)}}></LifeCycle>\n\t\t\t}\n\t\t}</RouterContext>\n\t}\n\t```\n\t\n\t* 这里需要 LifeCycle 组件的原因是我们需要一个组件 mounted 的时机，来帮助我们完成入栈操作，并且 redirect 还可以在 render 中顺利执行 return\n\n\n\t \n\t\t\n",
      "data": {
        "title": "React Router Essay",
        "date": "2020-03-08 10:51:31",
        "tags": [
          "React",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/react-router-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-router-essay"
    },
    {
      "content": "1. 如果我们想要实现一个裁剪组件，最核心的方法就是裁剪函数\n\n\t**裁剪函数需要用到 Html Canvas API** \n\n\t-  创建画布\n\n\t\t```js\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst ctx = canvas.getContext(\"2d\");\n\t\t```\n\n\t-  绘制图像\n\n\t\t```js\n\t\tctx.drawImage(img, dx, dy, width, height);\n\t\t```\n\t\t\t\t\n\t-  输出裁剪图像\n\t\n\t\t```js\n\t\t// 输出为 blob 格式\n\t\tcanvas.toBlob(blob=>{}, type, encoderOptions)\n\t\t// 输出为 dataUrl 格式\n\t\tcanvas.toDataURL(type, encoderOptions)\n\t\t```\n\t\t\t\t\n\t- 调整画布\n\n\t\t```js\n\t\t// 旋转\n\t\tctx.rotate()\n\t\t// 拉伸\n\t\tctx.translate()\n\t\t//缩放\n\t\tctx.scale()\n\t\t// ! save 只是保存的 CanvasRenderingContext2D 对象的状态以及对象的所有属性\n\t\tctx.save() / ctx.restore()\n\t\t```\n\t\t\n2. 当然裁剪组件不可能这么简单，我们还得需要一个容器，让使用者在里面进行图片的裁剪\n\n\t-  在容器内放置用户上传的图片，给图片设置 scale tanslate rotate 属性\n\t\n\t```html\n\t\t<div\n\t\t\tclass=\"cropper-box\"\n\t\t\t:style=\"{\n\t\t\ttransform: 'scale(' + scale + ',' + scale + ') ' + 'translate3d('+ x / scale + 'px,' + y / scale + 'px,' + '0)' +  'rotateZ('+ rotate * 90 +'deg)'\n\t\t}\"\n\t\t>\n\t\t\t<img :src=\"imgs\" />\n\t\t</div>\n\t```\n\t\t\n\t-  设置图片可拖拽区域，一般与容器大小相同，其中产生的x ， y 就是图片在容器左上角移动的距离\n\n\t```html\n\t    <div\n      class=\"cropper-drag-box\"\n      :class=\"{'cropper-move': canMove,'cropper-modal': cropping}\"\n      @mousedown=\"startMove\"\n      @touchstart=\"startMove\"\n    ></div>\n\t```\n\t\n3. 我们还需要一个裁剪框容器，裁剪框内出现的就是裁剪出的内容\n\n\t-  在裁剪框容器内同样放置用户上传的图片，给图片设置 scale tanslate rotate 属性\n\t\t\t\n\t```html\n\t<div class=\"cropper-view-box\">\n        <img\n          :src=\"imgs\"\n          :style=\"{\n\t\t\t\t\t\t'transform': 'scale(' + scale + ',' + scale + ') ' + 'translate3d('+ (x - cropOffsertX) / scale  + 'px,' + (y - cropOffsertY) / scale + 'px,' + '0)'\n\t\t\t\t\t\t+ 'rotateZ('+ rotate * 90 +'deg)'\n\t\t\t\t\t\t}\"\n        />\n\t</div>\n\t```\n\t\n\t**这里的 x - cropOffsertX 与 y - cropOffsertY 就是裁剪框内图片相对于裁剪框左上角的位置**\n\n\t-  设置图片可拖拽区域，一般与容器大小相同，其中产生的changeX, changeY就是裁剪框容器距外层容器左上角移动的距离，注意裁剪框不要超出外层容器即可。\n\n\t```html\n\t<span class=\"cropper-face cropper-move\" @mousedown=\"cropMove\" @touchstart=\"cropMove\"></span>\n\t```\n\n\t- 这里之所以还要放置一个与外面相同的图片，是为了让图片进入裁剪框时高亮显示，我们需要明白两张图片其实在视觉上在同一位置\n\n\t\t-  首先因为两张图片都是基于各自容器设置的绝对位置\n\n\t\t```css\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t\t```\n\t\n\t\t-  所以当 translate 时，外层裁剪容器根据自身移动时，移动为 x 与 y 那么内层裁剪框的根据自身移动 translate 就是 x- x - cropOffsertX 与 y - cropOffsertY，cropOffsertX 与 cropOffsertY 为裁剪框距离外层裁剪容器的距离\n\n\t-  还有一个逻辑较为复杂的地方是，裁剪框会被拉伸，随意改变大小\n\n\t\t- 首先判断改变的是 X 还是 Y\n\n\t\t- 在里层继续判断产生的 changeX 和 changeY 是正数还是负数，结合下层来判断裁剪框是增大还是减小\n\n\t\t- 继续在第三内层判断 change 与 crop 的大小， 因为存在两极反转的情况\n\n\t\t**比较绕，但我们可以这么想，首先第一层我们需要知道此时拖拽改变的是 X 还是 Y 轴，其次在 X 轴上裁剪框（正方形）存在两条边，那么我们就要第二层来知道产生的 change (拖拽距离) 为正还是为负，来分别处理两条边的情况，比如左边那条边 change 为负裁剪框增加，但是右边那条边却是减小。**\n\t\t\n\t\t**第三层 if 逻辑存在的理由是存在左边因为拖拽变成右边的情况（两极反转），在第三层里面，我们就去做 crop 大小和与外层容器距离的计算了（位置 + 大小 就能确定 crop 的情况了）**\n\t\t\n\t\t- 代码如下\n\n\t\t```js\n\t\tconst changeW = nowX - this.cropX;\n        const changeH = nowY - this.cropY;\n\n        if (this.canChangeX) {\n          if (this.changeCropTypeX === 1) {\n            // 判断「两极反转」的情况\n            if (this.cropOldW - changeW > 0) {\n              this.cropW =\n                this.containerWidth - this.cropPositionX - changeW <=\n                this.containerWidth\n                  ? this.cropOldW - changeW\n                  : this.cropOldW + this.cropPositionX;\n              this.cropOffsertX =\n                this.containerWidth - this.cropPositionX - changeW <=\n                this.containerWidth\n                  ? this.cropPositionX + changeW\n                  : 0;\n            } else {\n              // 左坐标线与右坐标线两极反转\n              this.cropW =\n                Math.abs(changeW) + this.cropPositionX <= this.containerWidth\n                  ? Math.abs(changeW) - this.cropOldW\n                  : this.containerWidth - this.cropW - this.cropPositionX;\n              this.cropOffsertX = this.cropPositionX + this.cropOldW;\n            }\n          } else if (this.changeCropTypeX === 2) {\n            if (this.cropOldW + changeW > 0) {\n              this.cropW =\n                this.cropOldW + changeW + this.cropPositionX <=\n                this.containerWidth\n                  ? this.cropOldW + changeW\n                  : this.containerWidth - this.cropPositionX;\n              this.cropOffsertX = this.cropPositionX;\n            } else {\n              // 左坐标线与右坐标线两极反转\n              this.cropW =\n                Math.abs(changeW + this.cropOldW) <= this.cropPositionX\n                  ? Math.abs(changeW + this.cropOldW)\n                  : this.cropPositionX;\n              this.cropOffsertX =\n                Math.abs(changeW + this.cropOldW) <= this.cropPositionX\n                  ? this.cropPositionX - Math.abs(changeW + this.cropOldW)\n                  : 0;\n            }\n          }\n        }\n\n        if (this.canChangeY) {\n          if (this.changeCropTypeY === 1) {\n            // 判断「两极反转」\n            if (this.cropOldH - changeH > 0) {\n              this.cropH =\n                this.cropPositionY + changeH >= 0\n                  ? this.cropOldH - changeH\n                  : this.cropPositionY + this.cropOldH;\n\n              this.cropOffsertY =\n                this.cropPositionY + changeH >= 0\n                  ? this.cropPositionY + changeH\n                  : 0;\n            } else {\n              this.cropH =\n                changeH - this.cropOldH <=\n                this.containerHeight - this.cropPositionY - this.cropOldH\n                  ? changeH - this.cropOldH\n                  : this.containerHeight - this.cropPositionY - this.cropOldH;\n\n              this.cropOffsertY = this.cropPositionY + this.cropOldH;\n            }\n          } else if (this.changeCropTypeY === 2) {\n            if (changeH + this.cropOldH > 0) {\n              this.cropH =\n                changeH <=\n                this.containerHeight - this.cropOldH - this.cropPositionY\n                  ? this.cropOldH + changeH\n                  : this.containerHeight - this.cropPositionY;\n\n              this.cropOffsertY = this.cropPositionY;\n            } else {\n              this.cropH =\n                Math.abs(changeH + this.cropOldH) <= this.cropPositionY\n                  ? Math.abs(changeH + this.cropOldH)\n                  : this.cropPositionY;\n\n              this.cropOffsertY =\n                Math.abs(changeH + this.cropOldH) <= this.cropPositionY\n                  ? this.cropPositionY - Math.abs(changeH + this.cropOldH)\n                  : 0;\n            }\n          }\n        }\n\t\t```\n\t\t\n**随笔真的很重要哇～**\n\t\n\t\t\n\t\t\n\n\t\t\n\t\t\t\t\n\t\t\n",
      "data": {
        "title": "Cropper Component Essay",
        "date": "2020-03-06 16:01:00",
        "tags": [
          "component",
          "Essay"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/cropper-component-essay.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cropper-component-essay"
    },
    {
      "content": "vue 组件间通信的方式有很多，有平时常常用到的，也有一些比较边界冷门的，所以有必要总结归纳一下，形成知识图谱，方便记忆。\n\n我们可以用传递层级来区分记忆：\n\n* 父传子\n* 子传父\n* 兄弟传递\n* 任意组件间\n* 祖先传后代\n\n### 父传子\n\n1. props\n2. $parent\n3. $attrs与$listener\n\n### 子传父\n\n1. $emit\n2. $children\n3. ref\n\n### 兄弟传递\n\n1. $parent\n2. $root\n\n### 任意组件间\n\n1. bus （常用 vue 实例，bus 的特点是谁监听谁触发）\n2. vuex\n\n### 祖先传后代\n\n1. provide/inject\n\n\n#### 参考资料\n[Vue 组件间通信六种方式（完整版）](https://juejin.im/post/5cde0b43f265da03867e78d3)",
      "data": {
        "title": "Vue 组件间通信",
        "date": "2020-01-01 13:15:36",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/vue-zu-jian-jian-tong-xin.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vue-zu-jian-jian-tong-xin"
    },
    {
      "content": "在前端代码构建中，我们使用 babel 将 ES2015 + 的代码转换为低版本的代码，来保证各个浏览器端的正常运行。但是在没有任何插件的情况下，babel 只会帮我们转换语法，不会转换类和方法。\n\n如果需要转换类和方法，就需要 polyfill 了。引入 polyfill ，主要有两种方法：\n\n### @babel/polyfill\n\n可以单独引入 @babel/polyfill, `import '@babel/polyfill'`，缺点很明显，**所有的 polyfill 都引进项目里了，可能会有几十K的大小，这个是没法忍的**\n\n### @babel/preset-env\n\n@babel/preset-env 搭配 @babel/polyfill 使用，可以根据 browserlists 来灵活的引用 polyfill。\n\n@babel/preset-env 里面有个 option 是 useBuiltins：\n\n* flase\n\t不启用 polyfill ，如果 `import '@babel/polyfill'`，会无视 browserlist 将所有的 polyfill 加载进来。\n* entry\n\t启用，需要手动 `import '@babel/polyfill'`，这样会根据 browserlist 过滤出需要的 polyfill\n* usage\n\t不需要手动 `import '@babel/polyfill'`，会根据 browserlist + 业务代码使用到的新 API 按需进行 polyfill\n\t\n\t**问题也有，那就是 polyfill 依旧是全局污染的，对于库或者组件代码，这样做是有风险的**\n\t\n### @babel/plugin-transform-runtime (暂时有问题)\n\n@babel/plugin-transform-runtime 需要搭配 @babel/runtime 使用，当然也是根据 preset 来判断。\n\n@babel/plugin-transform-runtime 用于构建过程中，@babel/runtime 是实际导入项目代码的功能模块。\n\n@babel/plugin-transform-runtime 做了三件事：\n\n* 自动请求 @babel/runtime/regenerator 当你使用 generators/async 方法时\n* 使用 core-js 假设用户使用了相关的 polyfill\n* 移除内联的 helpers ，将使用的 helpers 抽成一个模块并 require 引入\n\n好处是很明显的，此转换器将帮助你的代码创建沙盒环境，不会污染全局。\n\n但问题也有，**@babel/plugin-transform-runtime 不会转换实例方法**，因为如果转换实例方法，势必要修改原型链，这和不污染全局的初衷相悖。而且在我个人看来，**根据 preset 来判断，也没有 bowerlists 那么精确**。\n\n### polyfill.io\n\n以上的方案其实都有牺牲使用最新浏览器的用户的体验，而 polyfill.io 只需引入一个文件，就会根据当前浏览器来加载需要的 polyfill 文件，**但是考虑到面对国内浏览器各种奇葩的 UA，会有一些风险存在**。\n\n### 参考资料：\n* [@babel/polyfill 与 @babel/plugin-transform-runtime 详解](https://github.com/SunshowerC/blog/issues/4)\n* [babel能不能分析代码然后按需polyfill ？](https://juejin.im/post/5c09d6d35188256d9832df9d)\n* [21 分钟精通前端Polyfill方案](https://segmentfault.com/a/1190000010106158)\n* [babel-runtime使用与性能优化](https://juejin.im/entry/5b108f4c6fb9a01e5868ba3d)\n* [@babel/plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime#technical-details)\n* [ES6和Babel你不知道的事儿](https://juejin.im/entry/5a290988f265da43062aa986)\n\n",
      "data": {
        "title": "babel polyfill",
        "date": "2019-07-17 13:33:48",
        "tags": [
          "Babel"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "babel-polyfill"
    },
    {
      "content": "## 定义\n\n**虚拟 DOM 相当于是真实 DOM 和 js 之间的一层缓存，它可以帮助我们进行最小化的 DOM 操作，来保证视图更新的执行效率。**\n\n虚拟 DOM 算法主要分三部分\n\n* 用 JS 对象模拟 DOM树\n* 比较两棵虚拟 DOM 树的差异\n* 将差异应用到真正的 DOM 树上\n\n之前我们在[《高性能 javascript》总结](https://sfmonkey.github.io/post/2018-12-18-js-highPreformance/) 中提到过，js 引擎与 DOM 分属于两处不同的地方，在这中间的交互操作是十分消耗性能的，所以我们必须最小化 DOM 访问次数。Virtual DOM 正是帮助我们做到了这一点，Vritual DOM 并不是加快了 DOM 操作的速度，而是让页面在不同状态之间变化时，使用次数尽量少的 DOM 操作来完成。\n\n也由于包含这对比前后差异的过程，React 每次的 DOM 操作实际耗时是一定比我们执行原生 DOM 操作要长的。也就是说 React 是付出了额外的计算过程，来尽可能保持 DOM 操作的高效。\n\n## 算法实现\n\n以下的代码来自于 [livoras](https://github.com/livoras/blog/issues/13) 的实现。\n\n### 用 JS 对象模拟 DOM 树\n\n```javascript\n\t/**\n * 生成虚拟 DOM 函数\n * @param {String} tagName \n * @param {Object} props \n * @param {Array<Element|String>} children \n */\nfunction Element (tagName, props, children) {\n    if (!(this instanceof Element)) {   //创建 Element 对象\n        if (! (children instanceof Array) && children != null) {\n            children = Array.prototype.slice.call(arguments, 2).filter(function(v){return !!v}); // 处理 children 不是数组的情况\n        }\n        return new Element(tagName, props, children);\n    }\n\n\n    if (props instanceof Array) {\n        children = props;\n        props = {};  \n    }\n\n    this.tagName = tagName;\n    this.props = props || {};   //props 可能为空\n    this.children = children || []; //children 可能为空\n\n    this.key = props.key ? props.key : void 0; //获取元素 key , 用于之后 diff 比较时找到对应节点\n\n    var count = 0;  //记录子元素个数\n\n    children.forEach(function(child, i) {\n        if (child instanceof Element) {\n            count += child.count;\n        } else {\n            children[i] = '' + child;   //如果不是 Element 元素，保证 child 为字符串\n        }\n\n        count++;\n    });\n\n    this.count = count;\n}\n\n/**\n * 将虚拟 DOM 渲染为真实 DOM\n */\nElement.prototype.render = function () {\n    var el = document.createElement(this.tagName),  // 生成 DOM 节点\n        props = this.props,\n        children = this.children;\n\n    for (var k in props) {\n        if (props.hasOwnProperty(k)) {\n            var v = props[k];\n            el.setAttribute(k,v);   // 添加节点\n        }\n    }\n\n    children.forEach(function(child, i) {\n        var v = '';\n        if (child instanceof Element) {\n            v = child.render();\n        } else {\n            v = document.createTextNode(child);\n        }\n        el.appendChild(v);  // 添加子节点\n    });\n\n    return el;\n}\n```\n\n上面的函数实现了虚拟DOM的生成，那么这个函数怎么用呢？举个例子\n\n```javascript\nvar el = require('./element')\n\nvar ul = el('ul', {id: 'list'}, [\n  el('li', {class: 'item'}, ['Item 1']),\n  el('li', {class: 'item'}, ['Item 2']),\n  el('li', {class: 'item'}, ['Item 3'])\n])\n```\n\n我们可以将里面的参数看成 JSX， 这样是不是就有些眼熟了，那么如何将生成的虚拟 DOM 树渲染成真正的 DOM 呢\n\n```javascript\nvar ulRoot = ul.render()\ndocument.body.appendChild(ulRoot)\n```\n\n### 比较两棵虚拟 DOM 树的差异 （diff 算法）\n\n两棵树完全的 diff 算法的时间复杂度为 O(n^3) ，显然无法满足前端快速的 UI 响应，所以这里 React 改变了 diff 算法，只对同一层的DOM元素进行比较，将时间复杂度降为了 O(n)\n\n我们再来想想两个虚拟DOM树可能的差异类型：\n\n1. 替换之前的节点\n2. 移动，删除，新增子节点\n3. 改变了节点的属性\n4. 文本节点的内容发生了变化\n\n以下是实现\n\n```javascript\nfunction diff (oldTree, newTree) {\n    var index = 0;\n    var patches = {};\n\n    dfsWalk(oldTree, newTree, index, patches);\n\n    return patches;\n}\n\nfunction dfsWalk (oldNode, newNode, index, patches) {\n    var currentPatch = [];\n\n    if (newNode === null)  {\n\n    } else if (Object.prototype.toString.call(oldNode) && Object.prototype.toString.call(newNode)) {    // 比较文本节点的内容\n        if (newNode !== oldNode) {\n            currentPatch.push({type: patches.TEXT, content: newNode});\n        }\n    } else if (\n        oldNode.tagName === newNode.tagName &&\n        oldNode.key === newNode.key\n    ) {\n        //  比较属性的不同\n        var propsPatches = diffProps(oldNode, newNode);\n        if (propsPatches) {\n            currentPatch.push({type: patches.PROPS, props: propsPatches});\n        }\n\n        diffChildren(\n            oldNode.children,\n            newNode.children,\n            index,\n            patches,\n            currentPatch\n        );\n\n    } else {    // tagName 不同的情况\n        currentPatch.push({type: patches.REPLACE, node: newNode});\n    }\n\n    if (currentPatch.length) {\n        patches[index] = currentPatch;\n    }\n}\n\nfunction diffProps (oldNode, newNode) {\n    var oldProps = oldNode.props;\n    var newProps = newNode.props;\n\n    var key, value;\n    var propsPatches = {};\n\n    for (key in oldProps) {\n        if (oldProps.hasOwnProperty(key)) {\n            value = oldProps[key];\n            if (newProps[key] !== value) {\n                propsPatches[key] = newProps[key];\n            }\n        }\n    }\n\n    for (key in newProps) {\n        value = newProps[key]\n        if (!oldProps.hasOwnProperty(key)) {\n            propsPatches[key] = newProps[key];\n        }\n    }\n\n    if (JSON.stringify(propsPatches) === '{}') {\n        return null;\n    }\n    \n    return propsPatches;\n}\n\nfunction diffChildren (oldChildren, newChildren, index, patches, currentPatch) {\n    var diffs = listDiff();\n    newChildren = diffs.children;\n\n    if (diffs.moves.length) {\n        var reorderPatch = {type: patches.REORDER, moves: diffs.moves}\n        currentPatch.push(reorderPatch);\n    }\n\n    var leftNode = null;\n    var currentNodeIndex = index;\n\n    oldChildren.forEach(function(child, i) {\n        var newChild = newChildren[i]\n        currentNodeIndex = (leftNode && leftNode.count)\n          ? currentNodeIndex + leftNode.count + 1\n          : currentNodeIndex + 1\n        dfsWalk(child, newChild, currentNodeIndex, patches)\n        leftNode = child\n    });\n}\n```\n\n这里我们可以看出，其实每个新老节点在对比的时候，都是对比tagname，props和children，而在对比 children 时， 刚开始使用了 listDiff 算法，具体算法如下：\n\n```javascript\nfunction listDiff (oldList, newList, key) {\n    var oldMap = makeKeyIndexAndFree(oldList, key);\n    var newMap = makeKeyIndexAndFree(newList, key);\n\n    var newFree = newMap.free;\n\n    var oldKeyIndex = oldMap.keyIndex;\n    var newKeyIndex = newMap.keyIndex;\n\n    var moves = [];\n\n    var children = [];\n    var i = 0;\n    var item, itemKey;\n    var freeIndex = 0;\n\n    while (i < oldList.length) {\n        item = oldList[i];\n        itemKey = getItemKey(item, key); // 获取 key 的值, 它也是 newKeyIndex 的属性\n        if (itemKey) { //如果包含key\n            if (!newKeyIndex.hasOwnProperty(itemKey)) { // 新的列表里面没有老的列表元素,删除老的列表元素\n                children.push(null)\n            }  else {   // 新的列表里面有老的列表元素，又有key，移动和新增老的列表元素\n                var newItemIndex = newKeyIndex[itemKey];\n                children.push(newList[newItemIndex]);\n            }\n        } else {    //没有key的情况\n            var freeItem = newFree[freeIndex++];\n            children.push(freeItem || null);\n        }\n        i++;\n    }\n\n    var simulateList = children.slice(0);\n\n    // 删除新列表中不存在的元素,数组中剩下的是 1.新列表需要移动和新增的元素 2.新列表没有key的元素？？\n    i = 0;\n    while (i < simulateList.length) {\n        if (simulateList[i] === null) {\n            remove(i);\n            removeSimulate(i);\n        } else {\n            i ++;\n        }\n    }\n\n    var j = i = 0;\n    while (i < newList.length) {\n        item = newList[i];\n        itemKey = getItemKey(item, key);\n\n        var simulateItem = simulateList[i];\n        var simulateItemKey = getItemKey(simulateItem, key);\n\n        if (simulateItem) {\n            if (itemKey === simulateItemKey) {\n                j++;\n            } else {\n                if (!oldKeyIndex.hasOwnProperty(itemKey)) {\n                    // 新增\n                    insert(i, item);\n                } else {\n                    // 移动\n                    var nextItemKey = getItemKey(simulateList[j + 1], key);\n                    if (nextItemKey === itemKey) {\n                        remove(i);\n                        removeSimulate(j);\n                        j ++;\n                    } else {\n                        insert(i, item);\n                    }\n                }\n            }\n        } else {\n            insert(i, item);\n        }\n\n        i++;\n    }\n\n    var k = simulateList.length - j;\n    while (j++ < simulateList.length) {\n        k --;\n        remove(k + i);\n    }\n\n    function remove (index) {\n        var move = {index: index, type: 0}\n        moves.push(move);\n    }\n    \n    function insert (index, item) {\n        var move = {index: index, item: item, type: 1};\n        moves.push(move);\n    }\n\n    function removeSimulate (index) {\n        simulateList.splice(index, 1);\n    }\n}\n\nfunction makeKeyIndexAndFree (list, key) {\n    var keyIndex = {};\n    var free = [];\n\n    for (var i = 0, len = list.length; i < len; i++) {\n        var item = list[i];\n        var itemKey = getItemKey(item, key);\n        if (itemKey) {\n            keyIndex[itemKey] = i;\n        } else {\n            free.push(item);\n        }\n    }\n}\n\n/**\n * 获取数组元素key的值\n * @param {*} item \n * @param {String} key \n */\nfunction getItemKey (item, key) {\n    if (!item || !key) return void 0;\n    return typeof key === 'string'\n        ? item[key]\n        : key(item)\n}\n```\n\n其实，我们可以看出，listDiff 只是帮助我们记录了 children 列表元素应该移动，删除和新增的位置，具体移动后的元素，tagName ， props 如何变化，我们是在深度优先遍历的递归中做的，也就是到了下一个节点。\n\n### 把差异应用到真正的DOM树上\n\n现在我们已经得到了虚拟DOM树，以及新旧两个虚拟 DOM 树的差异，那边接下来我们就将 patches 应用到 DOM 树上。\n\n```\nvar REPLACE = 0;\nvar REORDER = 1;\nvar PROPS = 2;\nvar TEXT = 3;\n\nfunction patch (node, patches) {\n    var walker = {index: 0};\n    dfsWalk(node, walker, patches);\n}\n\nfunction dfsWalk (node, walker, patches) {\n    var currentPatches = patches[walker.index];\n\n    var len = node.childNodes ? node.childNodes.length : 0;\n\n    for (var i = 0; i < len; i++) {\n        var child = node.childNodes[i];\n        walker.index ++;\n        dfsWalk(child, walker, patches);\n    }\n\n    if (currentPatches) {\n        applyPatches(node, currentPatches)\n    }\n}\n\nfunction applyPatches (node, currentPatches) {\n    currentPatches.forEach(currentPatch => {\n        switch (currentPatch.type) {\n            case REPLACE:\n              var newNode = (typeof currentPatch.node === 'string')\n                ? document.createTextNode(currentPatch.node)\n                : currentPatch.node.render()\n              node.parentNode.replaceChild(newNode, node)\n              break\n            case REORDER:\n              reorderChildren(node, currentPatch.moves)\n              break\n            case PROPS:\n              setProps(node, currentPatch.props)\n              break\n            case TEXT:\n              if (node.textContent) {\n                node.textContent = currentPatch.content\n              } else {\n                // fuck ie\n                node.nodeValue = currentPatch.content\n              }\n              break\n            default:\n              throw new Error('Unknown patch type ' + currentPatch.type)\n          }\n    });\n}\n\nfunction setProps (node, props) {\n    for (var key in props) {\n      if (props[key] === void 666) {\n        node.removeAttribute(key)\n      } else {\n        var value = props[key]\n        _.setAttr(node, key, value)\n      }\n    }\n}\n\nfunction reorderChildren (node, moves) {\n    var staticNodeList = _.toArray(node.childNodes)\n    var maps = {}\n    \n    staticNodeList.forEach(node => {\n        if (node.nodeType === 1) {\n            var key = node.getAttribute('key')\n            if (key) {\n              maps[key] = node\n            }\n          }\n    });\n    \n    moves.forEach(function(move) {\n        var index = move.index\n        if (move.type === 0) { // remove item\n          if (staticNodeList[index] === node.childNodes[index]) { // maybe have been removed for inserting\n            node.removeChild(node.childNodes[index])\n          }\n          staticNodeList.splice(index, 1)\n        } else if (move.type === 1) { // insert item\n          var insertNode = maps[move.item.key]\n            ? maps[move.item.key].cloneNode(true) // reuse old item\n            : (typeof move.item === 'object')\n                ? move.item.render()\n                : document.createTextNode(move.item)\n          staticNodeList.splice(index, 0, insertNode)\n          node.insertBefore(insertNode, node.childNodes[index] || null)\n        }\n    });\n}\n```\n\n当然，以上算法开始于我们已经有了一个 tagname， props， children 的入参， 我们避开了 JSX，这也不是虚拟 DOM 算法应该关注的，还有什么时候去触发 update 函数，来进行 虚拟DOM 算法，这些无关主题的，也就都省略了。\n\n**猛兽总是独行**\n\n参考资料：\n[深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)\n[React的diffing算法学习](https://imweb.io/topic/5b67e47cf3fbd8d9125fe800)",
      "data": {
        "title": "对于 Virtual DOM 的理解",
        "date": "2019-07-04 17:13:04",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dui-yu-virtual-dom-de-li-jie"
    },
    {
      "content": "记得之前找实习的时候，面试官总喜欢问我： **遇到过的闭包的使用场景** ，那时候年轻啊，现在想想面试官希望我回答的，可能就是**偏函数**和**柯里化**吧。\n\n### 闭包\n> 闭包（closure）是函数和声明该函数的词法环境的组合。\n\n### 偏函数\n> 固定了你函数的某一个或几个参数，返回一个新的函数，接收剩下的参数, 参数个数可能是1个，也可能是2个，甚至更多,这就是偏函数。**偏函数相当于执行一次的柯里化**。\n\n```javascript\nadd = (x, y, z) => x + y + z\naddBySeven = Partial(Add, 7);\naddBySeven(5, 10); // returns 22;\n```\n\n### 柯里化\n> 只使用传递给函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n```javascript\nadd = (x, y, z) => x + y + z\ncurryAdd = Curry(add);    //Curry = x => y => z => x + y + z\naddBySeven = curryAdd(7);\naddBySeven(5)(10); // returns 22\n```\n\n### 当然我们今天的主菜是柯里化\n\n* 实际应用\n\t* 延迟计算\n\t```javascript\n\tconst add = (...args) => args.reduce((a, b) => a + b)\n\t\n\tconst currying = (func) => {\n\t\tconst args = [];\n\t\treturn function result (...rests) {\n\t\t\tif (rests.length === 0) {\n\t\t\t\treturn func(...args);\n\t\t\t} else {\n\t\t\t\targs.push(...rests);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tconst sum = currying(add);\n\n\tsum(1,2)(3); // 未真正求值\n\tsum(4); \t\t // 未真正求值\n\tsum(); \t\t\t // 输出 10\n\t```\n\t\n\t```javascript\n\t// 实现 bind 函数\n\tFunction.prototype.bind = function (context) {\n\t\tvar _ = this,\n\t\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\n\t\treturn () => {\n\t\t\t\tvar bindArgs = Array.prototype.slice.call(arguments);\n\t\t\t\t\n\t\t\t\treturn _.apply(context, args.concat(bindArgs));\n\t\t}\n\t}\n\t```\n\t\n\t* 动态创建函数\n\t```javascript\n\tconst addEvent =(function () {\n\t\tif (window.addEventListener) {\n\t\t\treturn function (type, el, fn, capture = false) {\n\t\t\t\tel.addEventListener(type, fn, capture);\n\t\t\t}\n\t\t} else if (window.attachEvent) {\n\t\t\treturn function (type, el, fn) {\n\t\t\t\tel.attachEvent('on' + type, fn);\n\t\t\t}\n\t\t}\n\t})()\n\t```\n\t\n\t* 参数复用\n\t```javascfript\n\tconst toStr = Function.prototype.call.bind(Object.prototype.toString);\n\t\n\t// 改造后\n\ttoStr([1, 2, 3]); \t// \"[object Array]\"\n\ttoStr('123'); \t\t// \"[object String]\"\n\ttoStr(123); \t\t// \"[object Number]\"\n\ttoStr(Object(123)); // \"[object Number]\"\n\t```\n\n* 实现 currying 函数\n```javascript\nconst currying = (fn, length) => {\n\tconst len = length || fn.length;\n\t\n\treturn function result(...args) {\n\t\tif (args.length >= len) {\n\t\t\treturn fn.apply(this, ...args);\n\t\t} else {\n\t\t\treturn currying(fn.bind(this, ...args), len - args.length)\n\t\t}\n\t}\n}\nconst fn = currying(function(a, b, c) {\n\t\tconsole.log([a, b, c]);\n});\nfn(\"a\", \"b\", \"c\") // [\"a\", \"b\", \"c\"]\nfn(\"a\", \"b\")(\"c\") // [\"a\", \"b\", \"c\"]\nfn(\"a\")(\"b\")(\"c\") // [\"a\", \"b\", \"c\"]\nfn(\"a\")(\"b\", \"c\") // [\"a\", \"b\", \"c\"]\n```\n\n#### 总结\n当然，从上面的三种应用场景可以看出，函数柯里化其实是一种工具方法，它将函数改造为更适合我们的模式，按照Stoyan Stefanov --《JavaScript Pattern》作者 的说法，所谓“柯里化”,  `就是使函数理解并处理部分应用` 。从闭包引入柯里化函数的概念，是因为根据概念 ： `只使用传递给函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数`，所以柯里化函数是必然包含闭包的。\n\n#### 以上\n\n#### 献出心脏！！\n\n参考资料：\n[柯里化和偏函数有什么区别?](https://segmentfault.com/q/1010000008626058)\n[深入高阶函数应用之柯里化](https://github.com/yygmind/blog/issues/37)\n[JavaScript 函数式编程技巧 - 柯里化](https://mp.weixin.qq.com/s/bnhMvxz3mVsuOx0QRrnL-w)\n\n\n\n\n\n\n",
      "data": {
        "title": "函数柯里化",
        "date": "2019-06-17 18:21:43",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/han-shu-ke-li-hua.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "han-shu-ke-li-hua"
    },
    {
      "content": "\n\n这段时间忙到根本无暇写博客，刚有时间写了，又想着写这么一个大的题目，人生果然每天充满挑战。\n\n## performance API\n\n说说起因吧，有一天老大说\n\n> “你在自己的模块里把性能分析加一下”\n\n于是我看了下公司内部的某个性能分析库和平台，以及它的文档。其中有一张图引人瞩目\n\n![](/images/get-file-event.png)\n\n这张图从一种纬度来反应了用户从输入 url 到页面加载完成发生的各种事件。我们来详细看看，这些事件都代表什么意思。\n\n### 事件周期\n\n* navigationStart\n\n    请求开始，用户在浏览器中输入了网址，并且点击了回车。\n\n* redirectStart\n\n    第一个 HTTP 请求发生重定向的时间，必须为同域名的跳转，否则值为 0。\n\n* redirectEnd\n\n    最后一个 HTTP 请求发生重定向的时间，必须为同域名的跳转，否则值为 0。\n\n* unloadStart\n\n    前一个网页 unload 的时间，必须与当前页面同域，否则为 0。\n\n* unloadEnd\n\n    前一个网页 unload 事件执行完毕的时间。\n\n* fetchStart\n\n    浏览器准备好发送 Http 请求文档，这发生在检查本地缓存之前。\n\n* domainLookupStart\n\n    DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n\n* domainLookupEnd\n\n    DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n\n* connnetStart\n\n    HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等\n    注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间\n\n* secureConnectionStart\n\n    HTTPS 连接开始的时间，如果不是安全连接，则值为 0\n\n* connectEnd\n\n    HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等\n    注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间\n    注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过\n\n* requestStart\n\n    Http 开始真正请求文档的时间，包括从本地读取缓存。\n\n* responseStart\n\n    TTFB 开始接收响应的时间，包括从本地读取缓存。\n\n* responseEnd\n\n    Http 响应全部接收完成，包括从本地读取缓存。\n\n* domLoading\n\n    开始解析渲染 DOM 树\n\n* domInteractive\n\n    完成解析 DOM 树的时间\n\n* domContentLoaded\n\n    网页内资源加载开始的时间，DOM 树开始渲染，DOMContentLoaded事件完成之后的时刻，也是javascript类库中DOM ready事件触发的时刻。这里可以理解为 渲染树构建完成。\n\n* domComplete\n\n    所有资源已下载完毕，加载转环已停止旋转\n\n* loadEventStart\n\n    load 回调函数开始执行的时间\n\n* loadEventEnd\n\n    load 事件执行完毕\n\n有了事件发生的时间，那我们如何利用这些事件？\n\n> performance API\n\n我们可以利用现代浏览器的 performance API 来进行事件的记录，API 里记录了事件发生的时间戳，我们可以因此完成性能统计。其实大多的性能分析库，就是利用这个 performance API 做到的。\n\n### 相关 API\n\n* performance.timing\n\n记录了各个事件的时间点\n\n* performance.getEntries()\n\n包含了页面中所有的 HTTP 请求\n\n* performance.now()\n\n可以精确计算程序执行时间，不像 Date now 可能会受系统程序的影响而变得不精准，performance.now() 输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间\n\n* performance.mark()\n\n可以通过传入 name ，便捷的批量标记事件发生点\n\n* performance.memory\n\nusedJSHeapSize 表示所有被使用的js堆栈内存；totalJSHeapSize 表示当前js堆栈内存总大小，这表示 usedJSHeapSize 不能大于 totalJSHeapSize，如果大于，有可能出现了内存泄漏。\n\n* performance.navigation\n\n    * performance.navigation.type\n\n        * 0：网页通过点击链接、地址栏输入、表单提交、脚本操作等方式加载\n\n        * 1：网页通过“重新加载”按钮或者location.reload()方法加载\n\n        * 2：网页通过“前进”或“后退”按钮加载\n\n        * 255：任何其他来源的加载\n\n    * performance.navigation.redirectCount\n\n        表示当前网页经过了多少次重定向跳转\n\n> 只有大量的模仿之后，你才有能力去创造。\n\n\n\n\n\n",
      "data": {
        "title": "前端性能分析总结（一）",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-9-27-preformance"
    },
    {
      "content": "Set、Map、WeakSet 和 WeakMap 都是 es6 推出的新的数据结构，主要是使用场景是 `数组去重` 和 `数据存储`\n\n## Set Map\n\nSet 是 `集合` 的一种体现，参数传入 key。而 Map 是 `字典` 的一种体现，参数传入 key-value。\n\nSet 和 Map 都可以存储不重复的值\n\n区别是集合以 键 形式存储元素，字典以 键-值 形式存储元素，键可以是任何数据结构\n\n## WeakSet WeakMap\n\n### WeakSet\n\nWeakSet的成员只能是对象，Set的成员不仅可以是对象还可以是其他类型的值\n\nWeakSet的一个最大的用处是：存储DOM结点，不用担心这些这些节点从文档中删除，引发内容泄露\n\n### WeakMap\n\nWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\n\n注册监听事件的listener对象很适合用WeakMap实现,因为将监听函数放在WeakMap中，一旦DOM对象消失，与它绑定的监听函数也会自动消失\n\n### 共同点\n\nWeakMap 和 WeakSet 只要外部引用消失，WeakMap内部的引用就会自动被垃圾回收清除\n\n> 当你感到不舒服，过的难受的时候，正是你成长的时候。\n\n参考资料:\n\n[ES6的Set和Map数据结构，由你制造](https://juejin.im/post/5acc57eff265da237f1e9f7c)\n\n[WeakSet和WeakMap](https://segmentfault.com/a/1190000016274121)",
      "data": {
        "title": "Set、Map、WeakSet 和 WeakMap",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2019-1-24-set-map"
    },
    {
      "content": "\n\n用 git 有一年多了，可能是由于平时项目的限制，感觉自己无法将 git 真正的威力发挥出来，昨天晚上又把 git 学习过了一遍，准备\n写篇文章，做个总结。\n\n`git init` 初始化仓库\n\n`git config` 设置用户名和邮箱, git config 的参数可以是 --global 也可以是 --local 视自己的情况而定\n\n    git config --global user.name \"\"\n    git config --global user.email \"\"\n\n`git clone` 克隆一个仓库\n\n`git remote` 查看与远程仓库的关联情况，也可以关联远程仓库\n\n    git remote add origin address\n\n`git add` 将文件添加到缓存区, `git add .` 与 -A 参数比较方便，可以一次全部添加，区别是 `git add .`有时无法添加 delete 文件\n\n    git add .\n    git add -A\n\n`git commit` 命令将文件从缓存区添加到本地仓库， -m 参数添加备注，--amend 参数补交文件，注意也要添加 -m 参数\n\n    git commit --amend -m \"\"\n\n`git status` 查看文件状态，在不更改默认配置的前提下，红色一般为 untracked 文件，绿色为添加到缓存区文件\n\n`git push` 推送本地修改到远端，这里最好加上远程仓库名与分支，可以使操作更快，-u 参数可以关联分支，为以后简化命令\n\n    git push -u origin master\n\n`git pull` 拉取远端仓库\n\n    git pull origin remote\n\n`git log` 查看历史提交记录，常用的参数有 --graph 会用图形化将提交记录显示出来，--all 会显示所有分支的提交记录\n    \n    git log --graph --all\n\n`git reflog` 查看命令历史，以便确定要回到未来的哪个版本（因为回到过去后，git log 也会回到过去）\n\n`git reset` 撤销回溯命令 \n\n* 修改已在版本库中\n    * --hard 参数直接将上一次的修改抛弃\n    * --soft 参数将上一次的修改放入缓存区\n    * --mixed 参数将上一次的修改放入工作区\n    \n    \n    git reset --hard commit_id\n\n* 修改可能不在版本库中(file 即文件名)\n    * 场景 1 :当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 `git checkout --file`\n    * 场景 2 :当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，第一步用命令 `git reset HEAD file`，第二步回到场景 1。\n    * 场景 3 :已经提交了不适合的修改到版本库，想要撤销本次提交，参考 修改已在版本库中\n\n`git diff` 比较文件差异、\n\n* git diff: 查看 working directory 与 staging area 之间的差异\n* git diff --cached: 查看 repository 与 staging area 之间的差异\n* git diff HEAD: 查看 working directory 与 repository 之间的差异\n\ndiff 差异比较可以看这篇文章 [读懂 diff](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)\n\n`git branch` 查看与创建分支，-d 删除分支。\n\n    git branch div\n\n`git checkout` 创建一个分支，并切换过去，切换分支与 tag。\n\n    git checkout -b dev\n\n`git tag` 为最新的 commit 打 tag，查看 tag\n\n`git push --tags origin master` 将本地所有 tag 都推送到远端，--tags 参数代表将所有的 tags 都推送到远端。\n\n`git push origin dev:dev` 将分支推送到远端仓库。\n\n`git merge` 合并分支，将指定分支合并到当前分支，这里和下面的 rebase 都涉及一个手动修改，若文件有多个分支同时修改，那么就要先手动解决冲突，之后再合并。\n\n`git rebase` 合并分支，简化分支模型，关于与 `git merge` 的具体区别，参考 [Git 速成班: git rebase](http://www.html-js.com/article/Week-end-column-Git-crash-course-git-rebase) 与 [git rebase 小计](http://www.cnblogs.com/kym/archive/2010/08/12/1797937.html)\n\n`git fetch` 获取远端修改，但是并不合并到当前分支。其实 `git pull` 就是 `git fetch` 和 `git merge` 组成的。\n\n`git stash` 保存工作现场，通过 `git stash list` 查看保存，通过 `git stash apply` 恢复，但是恢复后，stash 内容并不删除，你需要用 `git stash drop` 来删除,或者 `git stash pop` 直接恢复和删除。\n\n`git mv` 重命名文件,首先这个文件需要是已经是已追踪状态，才可以使用 git mv 命令，操作完成后自动处于 staging 状态。\n\n`.gitignore` 忽略的文件。这里使用 vim 编辑器打开 .gitignore ，这个文件记录了 git 忽略文件的规则。\n\n`git rm` 移除某文件，与 git add 相对，与 git add -A 命令有重叠作用，git rm --cached 将文件从 tracked 变为 untracked 。",
      "data": {
        "title": "git 学习总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-7-21-git"
    },
    {
      "content": "    我们用二叉树作为数据结构，来写出深度优先遍历和广度优先遍历。\n\n## 深度优先遍历\n\n> 该算法先将当前结点的孩子全部遍历结束，再遍历同一级的节点\n\n```javascript\n    // 递归\n    let res = [];\n    let dfs = function(node) {\n        if (node) {\n            res.push(node.val);\n            dfs(node.left);\n            dfs(node.right);\n        }\n    }\n    // 非递归\n    let dfs = function(nodes) {\n        let res = [];\n        let stack = [];\n        stack.push(nodes);\n        while (stack.length) {\n            let node = stack.pop();\n            res.push(node.val);\n            node.right && stack.push(node.right); // 先压入右子树\n            node.left && stack.push(node.left);\n        }\n        return res;\n    }\n```\n\n## 广度优先遍历\n\n当使用广度优先遍历的时候，先依次遍历兄弟节点，然后便利兄弟节点下的子节点，也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。\n\n```javascript\n    // 递归\n    let res = [],\n        stack = [],\n        count = 0;\n\n    stack.push(nodes);\n    let bfs = function() {\n        let node = stack[count];\n        if (node) {\n            res.push(node.val);\n            stack.push(node.left);\n            stack.push(node.right);\n            count ++;\n        }\n        bfs();\n    }\n\n    // 非递归\n    let bfs = function() {\n        let res = [],\n            stack = [],\n            count = 0;\n\n        stack.push(nodes);\n        while(stack.length){\n            let node = stack.shift();\n            res.push(node.value);\n            node.left && stack.push(node.left);\n            node.right && stack.push(node.right);\n        }\n        return res;\n    }\n```",
      "data": {
        "title": "深度优先遍历和广度优先遍历",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2019-1-29-bfs-dfs"
    },
    {
      "content": "最近多看了一些这方面的知识，算是入了门，在这里记录一些。\n\n### code splitting\n\n代码分割在wenpack 中共有三种方法：\n\n* entry 配置多个入口文件\n\t方便，快捷，但缺点也很明显，首先每个 chunk 都可能含有重复的模块，其次这样做的细粒度不够，并不能做到代码层面的分割。\n\t\t\n* splitChunks 抽取公有代码\n\tsplitChunks 可以帮助我们解决重复模块的问题。\n\t\t\n* 动态加载\n\twebpack 提供了两种方式来实现动态加载：\n\t* import()\n\t\t动态 import 导入是 es7 的语法，返回的是一个 promise ， 可以和 async 搭配服用，这也是 webpack 推荐的动态加载方式，需要注意的是，需要额外的 babel 插件 plugin-syntax-dynamic-import\n\t* require.ensure\n\t\t这是 webpack 实现的功能，但官方已不推荐使用了。\n\t\t\n\t在这里我们还需要了解一下 css 的代码分割，在 css 层面目前能做到的，就是抽取生成单独的 css 文件。目前有两个plugin 可以帮助我们很好的实现这一点： `extract-text-webpack-plugin@next` 和 `mini-css-extract-plugin`。\n\t\n### Tree Shaking\n\n* css tree shaking\n实现 css 的 tree shaking 需要借助 `purifycss-webpack` 这个插件，它会帮助我们清除无用的 css 代码\n\n\t```javascript\n\tconst PurifyCss = require('purifycss-webpack')\n\tconst glob = require('glob-all')\n\n\tplugins: [\n\t\t\tnew PurifyCss({\n\t\t\t\t\tpaths: glob.sync([\n\t\t\t\t\t\t\tpath.resolve(__dirname, './src/*.html'),\n\t\t\t\t\t\t\tpath.resolve(__dirname, './src/*.js')\n\t\t\t\t\t])\n\t\t\t})\n\t]\n\t```\n\t\n* js tree shaking\n在 webpack 中想要实现 tree shaking 是一件很不容易的事情，在webpack 中我们是靠 UglifyJS 来清除无用代码的，然而 UglifyJS 只能根据代码是否有副作用而不是程序流分析来删除代码。本来我们是可以知道自己的代码是否有副作用的，但是通过 babel 转译后，我们自己也无法保证了。想要了解详情可以看看[这里](https://juejin.im/post/5a5652d8f265da3e497ff3de)。\n\t这里我们只能做到自己应该做的：\n\t* 我们开发的是依赖库\n\t\t* 使用 rollup 进行打包并且提供 ES6 版本，在 package.json 中提供 module 字段。\n\t\t* 打包单独的组件文件，让用户通过目录去加载。\n\t* 我们开发的是工程项目\n\t\t* webpack4 以后只需将 mode 设置为 production ，即可引入 UglifyJS 插件。\n\t\t* 在 optimization 中，设置：\n\t\t\t```javascript\n\t\t\toptimization: {\n\t\t\t\t\tusedExports: true\n\t\t\t}\n\t\t\t```\n\t\t\n### DllPlugin\n\n我们引入的第三方库在一般情况下都不会有更改，所以可以使用插件将库打包成 dll 文件，在需要时直接引用。\n* 设置 dll config 文件\n```javascript\nmodule.exports = {\n\tmode: 'production',\n\tentry: {\n\t\treact: ['react']\n\t},\n\toutput: {\n\t\tpath: path.resolve(__dirname, './dll'),\n\t\tfilename: '[name].vendor.js',\n\t\tlibrary: '[name]_[hash]'     // manifest 里第三方库的名称\n\t\tlibraryTarget: 'this'\n\t},\n\tplugins: [\n\t\tnew webpack.DllPlugin({\n\t\t\tpath: path.resolve(__dirname, './dll/[name]-manifest.json'),\n\t\t\tname: '[name]_[hash]'\n\t\t})\n\t]\n}\n```\n\n* 在 package.json 中添加命令\n\t```javascript\n\t\"build:dll\": \"webpack --config webpack.dll.config.js\"\n\t```\n\t\n* 使用 dll 文件\n```javascript\n new AddAssetHtmlWebpackPlugin({     // 将 dll 文件引入 html\n\t filepath: path.resolve(__dirname, './dll/react.vendor.js') // 对应的 dll 文件路径\n }),\n new webpack.DllReferencePlugin({\n\t manifest: path.resolve(__dirname, './dll/react-manifest.json')\n })\n```\n\n### happypack\n\nhappypack 可以启用多个进程帮助我们并发处理打包任务，所以会快一些。\n\n```javascript\nconst os = require('os');\nconst HappyPackThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\nrules: [\n\t{\n\t\t\ttest: /\\.jsx?$/,\n\t\t\texclude: /node_modules/,\n\t\t\tuse: [\n\t\t\t\t\t{\n\t\t\t\t\t\t\tloader: 'happypack/loader?id=usedBabel'\n\t\t\t\t\t}\n\t\t\t]\n\t},\n]\nnew HappyPack({\n\tid: 'usedBabel',\n\tloaders: ['babel-loader'],\n\tthreadPool: HappyPackThreadPool\n}),\n```\n\n### PWA\n\nwebpack 主要是用了 google workbox 的 loader ，只需要一些简单的配置，就可以实现 PWA ，当然根据项目的实际情况，我们需要具体分析。\n\n```javascript\nconst WorkboxPlugin = require('workbox-webpack-plugin')\nconst prodConfig = {\n  plugins: [\n    new WorkboxPlugin.GenerateSW({\n      clientsClaim: true,\n      skipWaiting: true\n    })\n  ]\n}\n\n// 在入口文件添加\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker\n      .register('/service-worker.js')\n      .then(registration => {\n        console.log('service-worker registed')\n      })\n      .catch(error => {\n        console.log('service-worker registed error')\n      })\n  })\n}\n```\n\n#### 以上\n\n> 有些人的傲慢，来自于平时工作的严谨与负责\n\n\n\n\n",
      "data": {
        "title": "webpack 小谈",
        "date": "2019-06-14 17:41:20",
        "tags": [
          "webpack"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/webpack-xiao-tan.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "webpack-xiao-tan"
    },
    {
      "content": "\n前端发展到现在，不仅要将设计师的原型图完美展现，还要考虑到响应式、性能优化等诸多方面,所以性能分析是现在每个前端工程师的基础技能，从而来优化自己的页面，\n达到最佳用户体验的目的，但有时面对诸多的前端性能分析工具，我们会不知所措，其实很多时候，Chrome 开发者工具就可以帮助我们解决问题。它的 Timeline 和 Profiles \n版块可以帮助我们很好的分析页面性能。\n\n> 以下的 Chrome Devtools 均需要在隐身模式下服用，来保证功能的完备性和准确性。尽可能缩短记录时间和不必要的操作，关闭浏览器缓存。\n\n## Timeline (版本 54.0.2840.71)\n\n\n> Use the Chrome DevTools Timeline panel to record and analyze all the activity in your application as it runs. It's the best place to start investigating perceived performance issues in your application\n\n![](http://121.42.215.169/blog_images/timeline-10.png)\n\nTimeline 仪表盘包括四个窗口：\n\n![](http://121.42.215.169/blog_images/timeline-annotated.png)\n\n* Controls：开始记录，停止记录，配置在记录中需要捕获的信息。\n* Overview：性能总结分析页面。\n* Flame Chart：一个可视化的 CPU 堆栈跟踪。\n* Details： 当事件被选择时，这个窗口将展示这个事件的详细信息，当没有事件被选择时，展示所选时间段的信息。\n\nOverview 窗口 \n\nOverview 窗口包含三个曲线图：\n\n![](http://121.42.215.169/blog_images/overview-annotated.jpg)\n\n* FPS：Frames Per Second ，绿色的线条越高，FPS 越高。在 FPS 曲线上面的红色块表示长帧，即 FPS 低于 30。\n* CPU：CPU 资源，这个窗口显示各种类型事件所消耗的 CPU 资源。\n* NET：每种颜色代表一种资源。\n\n各个线条的颜色如下：\n\n* HTML 文件是蓝色。\n* scripts 是黄色。\n* stylesheets 是紫色。\n* Media 文件是绿色。\n* 混杂资源是灰色。\n\nFlame Chart 窗口\n\n![](http://121.42.215.169/blog_images/timeline-show.png)\n\n* Interactions ： 在 recording 过程中发生的交互操作，比如 MouseDown。\n* Main：记录主线程\n* Raster：线程光栅图\n* GPU：记录 GPU\n\nDetails 窗口：\n\n当我们选择一个事件，Details 窗口展示的是这个事件的附加信息。除过Summary 标签，它展示的是各个事件类型的详细情况。\n\n我们利用下面的程序来进行一次 Timeline 的操作实例\n\n我们以 Chrome Developers 中的一个例子来操作 Timeline 面板\n\n```javascript\nvar x = [];\n\nfunction createSomeNodes() {\n    var div,\n        i = 100,\n        frag = document.createDocumentFragment();\n    for (;i > 0; i--) {\n        div = document.createElement(\"div\");\n        div.appendChild(document.createTextNode(i + \"-\"+ new Date().toTimeString()));\n        frag.appendChild(div);\n    }\n    document.getElementById(\"nodes\").appendChild(frag);\n}\nfunction grow() {\n    x.push(new Array(1000000).join('x'));\n    createSomeNodes();\n    setTimeout(grow,1000);\n}\ngrow();\n```\n\n> When grow is invoked it will start creating div nodes and appending them to the DOM. It will also allocate a big array and append it to an array referenced by a global variable. This will cause a steady increase in memory that can be found using the tools mentioned above.\nGarbage collected languages usually show a pattern of oscillating memory use. This is expected if code is running in a loop performing allocations, which is the usual case. We will be looking for periodic increases in memory that do not fall back to previous levels after a collection.\n\n\n运行这个脚本网页后，我们打开 Timeline, record 记录 10s 运行情况后停止。同时记得记录结束后给 grow 函数加上断点，防止页面崩溃。\n在 overview 中选择一个时间段，观察 flame chart 中的大致情况，出现红色长块，说明这里出现了长帧。点击红色长块，可以在 Details 窗口查看详细信息。flame chart 的 main 里面有更加详细的事件顺序和消耗时间。同样点击后在 Details 窗口可显示详细信息。\n\n从下面的线性图中我们可以清晰的看出内存在不断的增加，这会导致页面最终崩溃。\n\n![](http://121.42.215.169/blog_images/timeline-node.png)\n\n可以看出，Nodes 和 JS Heap 都在不断上升，中间下降的那段是因为 js 的垃圾回收机制起的作用，但很明显，内存还是在周期性的泄露，这是一个危险的标志。那么我们如何来找到和解决这个问题呢？\n\n## Profiles (版本 54.0.2840.71)\n\n> Use the Profiles panel if you need more information than the Timeline provide, for instance to track down memory leaks.\n\n![](http://121.42.215.169/blog_images/take-heap-snapshot.png)\n\n在 Profiles 面板上有四个配置类型：\n\n* Record JavaScript CPU Profile：监控函数执行期花费的时间\n* Take Heap Snapshot：保存内存快照\n* Record Allocation Timeline：帮助你在 JS 堆里追踪内存泄露\n* Record Allocation Profile：通过 JS 函数帮助你查看内存分配\n\n同样，我们用一个例子来说明问题：\n\n``` javascript\n<!DOCTYPE html>\n<html>\n<body>\n<script type=\"text/javascript\">\n                var ClassA = function(name){\n                        this.name = name;\n                        this.func = null;\n                };\n                var a = new ClassA(\"a\");\n                var b = new ClassA(\"b\");\n                b.func = bind(function(){\n                        console.log(\"I am \" + this.name);\n                }, a);\n                b.func();  //输出 I am a\n\n                a = null;        //释放a\n                //b = null;        //释放b\n                //模拟上下文绑定\n                function bind(func, self){\n                                return function(){\n                                return func.apply(self);\n                        };\n                }; \n</script>\n</body>\n</html>\n```\n\nRecord JavaScript CPU Profile:\n\n![](http://121.42.215.169/blog_images/profile-cpu.png)\n\n这个面板的功能比较简单，从上图可以看到点击按钮执行的各个函数执行的时间，顺序，包含关系和CUP变化等\n\nTake Heap Snapshot:\n\n![](http://121.42.215.169/blog_images/profile-snapshot.png)\n\n这里解释几个名词：\n\n* Constructor：表示所有通过该构造函数生成的对象\n* Distance：对象到达 GC 根的最短距离\n* Objects Count：对象的实例数\n* Shallow size：对应构造函数生成的对象的 shallow sizes（直接占用内存）总数\n* Retained size：展示了对应对象所占用的最大内存\n\n关于GC根的解释有点麻烦：它指的是一个对象指针最开始指向的内存。可以用一张图来理解：\n\n![](http://121.42.215.169/blog_images/progile-gc.jpg)\n\n构成这张关系网的元素有两种：\nNodes：节点，对应一个对象，用创建该对象的构造方法来命名\nEdges：连接线，对应着对象间的引用关系，用对象属性名来命名\n根据上面的定义解释，图中的对象 6 到CG根的距离就是 3 。\n\n![](http://121.42.215.169/blog_images/profile-comparison.png)\n\n可以看到有两个ClassA对象，这与我们的本意不相符，我们释放了a，应该只存在一个ClassA对象b才对。\n\n当 b.func = null 时\n\n![](http://121.42.215.169/blog_images/profile-snapshot-extra.png)\n\n从上面两个图可以看出这两个对象中，一个是 b，另一个并不是 a，因为 a 这个引用已经置空了。第二个 ClassA 对象是bind里的闭包的上下文 self，self 与 a 引用同一个对象。虽然 a 释放了，但由于 b 没有释放，或者 b.func 没有释放，使得闭包里的 self 也一直存在。要释放 self，可以执行 b=null 或者 b.func=null\n\n![](http://121.42.215.169/blog_images/profile-snapshot-2.png)\n\n这里需要对 shallow size 和 retained size 做一下解释：\n\n>直接占用内存指的是对象本身占用的内存，因为对象在内存中会通过两种方式存在着，一种是被一个别的对象保留（我们可以说这个对象依赖别的对象）或者被Dom对象这样的原生对象隐含保留。在这里直接占有内存指的就是前一种。(通常来讲，数组和字符串会保留更多的直接占有内存)。而最大内存(Retained size)就是该对象依赖的其他对象所占用的内存\n\n我们会发现在快照的 JS 方法中有红黄两种颜色，黄色即直接占用内存，红色即间接占用内存，我们需要关注这两种情况的内存回收情况。\n\n一个快照有四个试图类型：\n\n* Summary(概要) – 通过构造函数名分类显示对象；\n* Comparison(对照) – 显示两个快照间对象的差异；\n* Containment(控制) – 探测堆内容；\n* Statistic(图形表)-用图表的方式浏览内存使用概要\n\n通过 Comparison ，我们可以观察两个试图之间增加和删除的对象。\n\n顺带提一句，Retainers 视图显示出了该对象被哪些对象引用了\n\nRecord Allocation Timeline:\n\n关于这个面板，我们使用以下代码来进行演示：\n\n```javascript\nvar x = [];\n\nfunction grow() {\n  x.push(new Array(1000000).join('x'));\n}\n\ndocument.getElementById('grow').addEventListener('click', grow);\n```\n\n![](http://121.42.215.169/blog_images/new-allocations.png)\n\n每一个蓝条的出现都预示着内存泄露的可能，选择其中一个蓝条进行分析\n\n![](http://121.42.215.169/blog_images/zoomed-allocation-timeline.png)\n\n\n\nRecord Allocation Profile:\n\n![](http://121.42.215.169/blog_images/allocation-profile.png)\n\n![](http://121.42.215.169/blog_images/object-details.png)\n\n> 性能分析很重要，前端的前辈们在很长一段时间里处于黑暗的年代中。现在已经初现光明，所以我们是很幸运的。\n",
      "data": {
        "title": "利用 Chrome DevTools 进行网页性能分析",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-11-18-timeline-profile"
    },
    {
      "content": "\n这两天在写一些网页的时候,发现自己得到了一些琐碎的知识点,这种东西,还是赶快写下来比较好\n\n## box-sizing\n\n这个属性对我们平时开发的帮助之大,不言而喻,在这里涉及一个盒子的真正大小问题\n\n    border + padding + width = 盒子的宽度\n    border + padding + height = 盒子的高度\n\n所以,我们在写一些盒子时,实际的大小往往偏大,这让我们还原设计时的工作量变的多了起来. box-sizing 帮助我们解决了这个问题,在这个属性下,如果我们设置了 padding 和 border,盒子的 content 将自动减小,来保证盒子的总大小是我们设置的 width 和 height 值.\n\n我们常用的属性值是 border-box ,同样的,可以设置为 content-box , 这是浏览器的默认值,也就是 content 的宽高度. inherit 值用来继承父级元素的属性值.\n\n> 该属性兼容 IE8+ ,FF 需要加 -moz- 前缀, 低版本的 ios 和 android 需要加 -webkit- (手机浏览器是 webkit 内核当道).\n\n## 解决缩放图片的问题\n\n很多时候,我们都会遇到图片的缩放问题.\n\n1.在要保证不变形的情况下,我们只能将图片按照原宽高比进行缩放,在有的时候考虑到自适应的情况,我们可以利用 width 和 padding 的百分比来进行缩放.\n2.利用 background-size 属性, cover 为等比扩容填满元素 , contain 等比缩小适应元素尺寸, auto 是图片自身的大小.\n\n## 三栏式布局\n\n我们在这里默认两边宽度不变\n\n1.绝对定位法\n\n左右两栏采用绝对定位,分别固定于页面的左右两侧,中间的主体栏用左右 margin 值撑开距离.\n\n2.负 margin (双飞翼)\n\n首先,中间的主体要使用双层标签.外层 div 宽度 100% 显示,并且浮动,\n内层 div 为真正的主体内容,含有左右的 margin 值,左栏与右栏都是采用 margin 负值定位的, 左栏左浮动, margin-left 为 -100%,由于前面的 div 宽度100% , 所以这里的 -100% margin 值正好使左栏 div 定位到了页面的左侧,右侧栏也是做浮动,其 margin-left 也是负值,大小为其本身的宽度.\n\n3.自身浮动法\n\n左栏左浮动,右栏右浮动,主体直接放后面,加上margin 值 ,就实现了自适应.\n\n## css 浮动\n\n之所以写这个完全是因为看到了一篇好文,觉得很有必要记录\n\n> 假如某个 div 元素A 是浮动的,如果 A 元素上一个元素也是浮动的,那么 A 元素会跟随在上一个元素的后边(如果一行方不下这两个元素,那么A 元素会被挤到下一行);如果 A 元素上一个元素是标准流中的元素,那么A 的相对垂直位置不会改变,也就是说A 的顶部总是和上一个元素的底部对齐. div 的顺序是 HTML 代码中 div 的顺序决定的.靠近页面边缘的一端是前,远离页面边缘的一端是后.\n\n## 利用 css 绘制各种图形\n\n1.圆\n\n```css\n#circle{\n  width:100px;\n  height:100px;\n  background: red;\n  -moz-border-radius:50px;\n  -webkit-border-radius:50px;\n  border-radius: 50px;\n}\n```\n\n2.椭圆\n\n```css\n#oval{\n  width: 200px;\n  height: 100px;\n  background: red;\n  -moz-border-radius:100px/50px;\n  -webkit-border-radius:100px/50px;\n  border-radius: 100px/50px\n}\n```\n\n3.三角形\n\n```css\n#triangle-up{\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n}\n```\n\n4.平行四边形\n\n```css\n#parallelogram{\n  width:150px;\n  height: 100px;\n  -webkit-transform:skew(20deg);\n  -moz-transform:skew(20deg);\n  -o-transform:skew(20deg);\n  background: red;\n}\n```\n\n5.半圆和四分之一圆\n\n```css\n#quartercircle{\n  width: 200px;\n  height: 200px;\n  background: red;\n  -webkit-border-radius:200px 0 0 0;\n}\n```\n\n```css\n#quartercircle {\nwidth: 200px;\nheight: 200px;\nbackground-color: red;\n-webkit-border-radius: 0 0 200px 200px;\n}\n```\n\n## centering in css\n\n1.水平居中\n\n(1) inline or inline-* elements\n\n```\ntext-align:center\n```\n\n(2) block level element\n\n```\nmargin:0 auto\n```\n\n(3) more than one block level element\n\nin a row\n\n```css\n.inline-block-center{\n  text-align:center\n}\n\n.inline-block-center div{\n  display:inline-block;\n  text-align:left\n}\n\n.flex-center{\n  display: flex;\n  justify-content: center\n}\n```\n\nstacked on top of each other\n\n```\nmargin:0 auto\n```\n\n2.垂直居中\n\n(1) inline or inline-* elements\n\nsingle inline\n\n```css\n.link{\n  padding-top: 30px;\n  padding-bottom: 30px\n}\n\n.link{/*height 固定*/\n  height:30px;\n  line-height:30px\n}\n```\n\nmultiple lines\n\n```css\n.center-table {\n  display: table;\n  height: 250px;\n  background: white;\n  width: 240px;\n  margin: 20px;\n}\n.center-table p {\n  display: table-cell;\n  margin: 0;\n  background: black;\n  color: white;\n  padding: 20px;\n  border: 10px solid white;\n  vertical-align: middle;\n}\n\n.flex-center-vertically {\n  display: flex;\n  justify-content: center;\n  flex-direction: column;\n  height: 400px;\n}\n\n.ghost-center {\n  position: relative;\n}\n.ghost-center::before {\n  content: \" \";\n  display: inline-block;\n  height: 100%;\n  width: 1%;\n  vertical-align: middle;\n}\n.ghost-center p {\n  display: inline-block;\n  vertical-align: middle;\n}\n```\n\n(2) block elements\n\nknow width and height\n\n```css\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  height: 100px;\n  margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */\n}\n```\n\ndo not know\n\n```css\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n```\n\nflex\n\n```css\n.parent {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n```\n\n3.水平垂直居中\n\nknow width and height\n\n```css\n.parent {\n  position: relative;\n}\n\n.child {\n  width: 300px;\n  height: 100px;\n  padding: 20px;\n\n  position: absolute;\n  top: 50%;\n  left: 50%;\n\n  margin: -70px 0 0 -170px;\n}\n```\n\n```css\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n```css\n.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n```\n\n参考资料:\n[让CSS布局更加直观：box-sizing](http://web.jobbole.com/82331/)\n\n[深入理解CSS中的行高](http://www.cnblogs.com/rainman/archive/2011/08/05/2128068.html)\n\n[我熟知的三种三栏网页宽度自适应布局方法](http://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/)\n\n[经验分享：CSS浮动(float,clear)通俗讲解](http://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html)\n\n[The Shapes of CSS](https://css-tricks.com/examples/ShapesOfCSS/)\n\n[CSS3:border-radius隐藏的威力](http://www.xincss.com/?p=221)\n\n[Centering in CSS: A Complete Guide](https://css-tricks.com/centering-css-complete-guide/)\n",
      "data": {
        "title": "碎片化知识总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2017-3-4-learn-conclution"
    },
    {
      "content": "\n\n在自己负责的一次版本需求中，涉及到了对 URL 编码的一些操作，发现自己理解不是很清晰，于是学习总结了一番\n\n## 为什么要对 URL 进行编码\n\n网络标准 RFC 中明确规定，url 只允许英文字母、阿拉伯字母和一些标点符号，所以在这个范围之外的字符，需要强行对其进行编码。\n\n## 采取什么编码规定\n\n没有明确的规定，url 的编码可能会根据网页字符集、浏览器和操作系统有不同的编码方式。\n\n## 解决方案\n\n如果 url 采取不同的编码方式，那么势必会造成解码困难，所以我们需要对编码方式进行统一，在这里，JS 提供了 API 函数。\n\n在了解这几个函数之前，我们首先需要明确几个概念。\n\n* URL URI URN\n\n    * URI（Uniform Resource Identifier，统一资源标识符)是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。\n\n    * URL(Uniform Resource Locator，统一资源定位符），最常见的形式是 URI,经常指定为非正式的网址。\n\n    * URN（Uniform Resource Name，统一资源名称），其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址。\n\n    > URN 如同一个人的名称，而 URL 代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法,两者互补且有交集。URN 和 URL 是 URI 的子集。\n\n* URL 保留字符\n\n    > ! * ' ( ) ; : @ & = + $ , / ? # [ ]\n\n## JS API\n\n* encodeURI 和 decodeURI \n\n这两个 API 函数对整个 url 进行操作，它们假定 URI 中保留字符都有其特殊含义，所以不会编解码它们。\n\n* encodeURIComponent 和 decodeURIComponent \n\n这两个 API 函数是对 url 的部分进行操作，它们会将保留字符认为是普通文本，而进行编解码。\n\n## 问题来了\n\n* url 进行了编码后，难道后端每次还得解码？\n\n后端的 web 框架会帮助程序员处理一次解码。\n\n* 那么如果我不是通过 js ，而是直接在浏览框中输入了 url，那么编码不是不能控制了吗？\n\n答案是的确不能控制，但由于现代浏览器或操作系统，大多数的编码字符集，在后端的 web 框架中都能识别，所以不会存在问题，如果真遇到不能识别的情况，那就真的乱码了。\n\n> 在足够强大之前，请不要对别人流露自己的友善。\n\n参考资料:\n\n[关于 URL 编码](http://www.ruanyifeng.com/blog/2010/02/url_encoding.html)\n\n[URI、URL、URN 的联系和区别](https://waylau.com/difference-of-uri-url-urn/)\n",
      "data": {
        "title": "对于 URL 编码的一点理解",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-10-25-url"
    },
    {
      "content": "\n\n花了两天时间搭了博客，利用 Githu pages + jekyll + markdown 实现的，页底的评论用的是国外的 Disqus ，\n就是在内嵌 Disqus 时，发现自己遇到了一个经典的 footer 布局问题，搞了一下午，终于明白了一些。\n\n实现 footer 有两类方法，CSS 和 JavaScript\n\n* CSS\n\n     * position\n    \n        * fixed 固定在可视窗口最底部\n        \n                 position: fixed;\n                 bottom: 50px;\n            \n        * absolute 显示在可视窗口的最底部\n        \n                position: absolute;\n                bottom: 50px;\n               \n        * relative 显示在页面的最底部\n                        \n                position: relative;\n                bottom: 50px;\n            \n        使用 position 有很大的缺点，position 不能完美满足 footer 的布局要求。\n    \n    * 推拉推原理\n        \n            1. 设置 div.wrapper 高度为整个网页\n            2. 将推到下一页的 footer 使用 margin-bottom 拉回\n            3. 为避免设置了负边距的页面内容与 footer 重叠，所以使用 div.push 或者.main 的 padding-bottom 或者 wrapper:after 再次推开 footer\n         \n        * div.push 写法\n        \n                <body>\n                    <div class=\"wrapper\">\n                        <div class=\"main\">\n                        </div>\n                        <div class=\"push\"></div>\n                    </div>\n                    <footer class=\"footer\">...<footer>\n                </body>\n                    \n                            html 结构\n                            \n                html,body{\n                    height: 100%;\n                    padding: 0;\n                    margin: 0;\n                }\n                .wrapper{\n                    min-height:100%;\n                    margin:0 auto -400px;       \n                }\n                \n                .push {\n                    height:326px;\n                }\n                \n                            div.push 写法\n                            \n        * .main 的 padding-bottom 写法\n        \n                <body>\n                        <div class=\"wrapper\">\n                            <div class=\"main\">\n                            </div>\n                        </div>\n                        <footer class=\"footer\">...<footer>\n                </body>\n                        \n                                html 结构\n                                \n                    html,body{\n                        height: 100%;\n                        padding: 0;\n                        margin: 0;\n                    }\n                    .wrapper{\n                        min-height:100%;\n                        margin:0 auto -326px;       \n                    }\n                    .main {\n                        padding-bottom: 400px;\n                    }\n                    \n                                padding-bottom  写法\n                                \n        * .wrapper : after\n        \n                <body>\n                            <div class=\"wrapper\">\n                                <div class=\"main\">\n                                </div>\n                            </div>\n                            <footer class=\"footer\">...<footer>\n                </body>\n                            \n                                    html 结构\n                                    \n                        html,body{\n                            height: 100%;\n                            padding: 0;\n                            margin: 0;\n                        }\n                        .wrapper{\n                            min-height:100%;\n                            margin:0 auto -326px;       \n                        }\n                        .wrapper:after{\n                            content:\"\";\n                            display:block;\n                            height: 400px;\n                        }\n                        \n                                    :after  写法\n\n        * flex 写法\n        \n                <body>\n                            <div class=\"wrapper\">\n                                <div class=\"main\">\n                                </div>\n                            </div>\n                            <footer class=\"footer\">...<footer>\n                </body>\n                            \n                                    html 结构\n                                    \n                        html,body{\n                            display:flex;\n                            min-height:100vh;\n                            flex-direction: column;\n                        }\n                        .main {\n                            flex:1;\n                        }\n                        \n                                    padding-bottom  写法\n\n* Javascript\n\n    * 计算高度，设置 footer 的位置。\n\n引用自简书 [scarqin](http://www.jianshu.com/users/9f4b86bd9c0e/latest_articles) 的博客与 [demo](http://htmlpreview.github.io/?https://github.com/scarqin/ripple-new/blob/master/footer/method.html) \n参考资料： [footer 的各种写法](http://www.jianshu.com/p/c91eee6849cb)",
      "data": {
        "title": "footer 布局总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-7-19-footer"
    },
    {
      "content": "\n\n在上一篇博客 [footer 布局总结](https://sfmonkey.github.io/blog/2016/07/footer.html)中，有关于负 margin 的应用提及，负 margin 的\n使用可以替代那些较危险的 relative/absolute 属性，还可以达到一般 CSS 属性所不能达到的效果， 化繁为简、化腐朽为神奇。\n\n一个完整的 margin 属性是这么写的\n```css\nmargin：top right bottom left;\n```\n根据[海玉](http://www.hicss.net/)的博客，我们可以引入两类参考线来解释 margin 问题，top 和 left 的参考线属于一类， right 和 bottom 的\n参考线属于一类。top 和 left 是以外元素为参考，right 和 bottom 是以元素本身为参考。\n\n首先，我们来看一个[demo](https://sfmonkey.github.io/demo/margin.html)\n\n当我们改变top 与 left 属性时，这条参考线就是该元素的紧邻元素的边界（包括 margin ），如果 top 和 left 是负的，那么以上面的 demo 为例，example\n元素会以 wrapper 元素边缘为基准，反过来向上和向左推进一段距离。\n\n当我们改变 right 和 bottom 属性时，这条参考线就是它自身的边界，如果 right 和 bottom 是负的，那么以上面的 demo 为例，下方的 normal 元素会以 example \n元素边缘为基准，normal 元素向上提，如果 normal 是内联元素，normal 元素向左提。\n\n关于负 margin 的一些[实例](http://www.hicss.net/i-know-you-do-not-know-the-negative-margin/)\n\n参考资料:[我知道你不知道的负 Margin ](http://www.hicss.net/i-know-you-do-not-know-the-negative-margin/)\n\n    海玉的博客需要科学上网浏览",
      "data": {
        "title": "负 margin 学习总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-7-19-margin"
    },
    {
      "content": "最近阅读了《高性能 javascript》这本书，虽然在现在看来书中的部分知识已经过时了，但还是有很多值得我们拜读的地方，故总结一下。\n\n## 加载和执行\n\n> 大多数浏览器使用单一进程来处理 UI 刷新和 JS 脚本执行，所以同一时间只能干一件事。 JS 的执行过程耗时越久，浏览器等待响应的时间就越长。\n\n如果外链 JS 的加载不是异步的，它会阻塞 DOM 的解析和渲染。\n\n每次遇到 script 标签，页面都会停下来等待代码的下载（如果是外链JS）并执行，然后处理其他部分。\n\n所以我们需要减少 JS 对于性能的影响。\n\n* 尽可能将 JS 放在 body 标签最后面，这样能确保脚本执行前页面已经完成了渲染\n\n* 合并脚本，页面中的 script 标签越少，加载也就越快\n\n* 无阻塞下载 JS\n\n    * defer async 属性\n\n    * 动态创建 script 标签实现异步加载\n\n    * 使用 XHR 对象下载 JS 代码并注入页面\n\n## 数据存取\n\n> 在 JS 中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有四种方式：字面量、变量、数组项、对象成员。它们有着各自的性能特点。\n\n* 访问字面量（字面量只代表自身，不存储在特定位置）和局部变量的速度最快，相反，访问数组和对象相对缓慢。\n\n* 变量在作用域链中的位置越深，访问速度也就越慢，由于全局变量处于作用域链的最末端，所以访问速度是最慢的。\n\n* 避免使用 with 语句和 try-catch 中的 catch 子句，因为它们会改变执行环境的作用域链。\n\n* 嵌套的对象成员（如 window.location.href）会明显的影响性能，尽量少用。\n\n* 属性和方法在原型链中的位置越深，访问它的速度就越慢。\n\n* 通过把常用的对象成员，数组元素，跨域变量保存在局部变量中来改善 JS 性能。\n\n## DOM 编程\n\n> 访问和操作 DOM 是现代 Web 应用的重要部分，但每次穿越连接 ECMAScript 和 DOM 两个岛屿之间的桥梁，都会被收取 “过桥费”，为了减少 DOM 编程带来的性能消耗，需要注意一些地方。\n\n* 最小化 DOM 访问次数。\n\n* 如果需要多次访问某个 DOM ，请使用局部变量存储它的引用。\n\n* 小心使用 HTML 集合，因为它实时连系着底层文档，把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。\n\n* 使用速度更快的 API，比如 querySelectorAll 和 firstElementChild\n\n* 要留意重绘和重排，批量修改样式时，“离线” 操作 DOM 树，使用缓存，并减少访问布局信息的次数。\n\n* 动画中使用绝对定位，使用拖放代理。\n\n* 使用事件委托减少事件处理器的数量。\n\n## 算法和流程控制\n\n> js 和其他编程语言一样，代码的写法和算法会影响运行时间。\n\n* for，while 和 do-while 循环性能相当。\n\n* 避免使用 for-in 循环，除非你需要遍历一个属性数量未知的对象。\n\n* 改善循环性能最佳的方式是减少每次迭代的运算量和减少迭代循环的次数。\n\n* 当条件分支到达一定程度时，对象优于 switch 优于 if-else\n\n* 浏览器的调用栈大小限制了递归算法在 JS 中的应用。\n\n* 任何递归算法都可以用迭代来代替，或使用 Memoization（该函数会缓存特定参数的函数调用结果） 来避免重复计算。\n\n## 字符串和正则表达式\n\n> 密集的字符串操作和草率的编写正则表达式可能会产生严重的性能障碍。\n\n* 在大量的字符串合并中，数组项合并是最慢的字符串连接方法之一，推荐使用简单的 + 和 += 操作符替代。\n\n* 使互邻的字元互斥，避免嵌套量词对同一字符串的相同部分多次匹配，通过重复利用预查的原子组去除不必要的回溯，以此来避免回溯失控。\n\n* 正则表达式并不总是完成工作的最佳方式，尤其当你只搜索字面字符串的时候。\n\n## 快速响应的用户界面\n\n> JS 和用户界面更新在同一个进程中运行，因此一次只能处理一件事情。这意味着当 JS 代码正在运行时，用户界面不能响应输入（点击事件等），反之亦然。高效地管理 UI 线程就是要确保 JS 不能运行太长时间，以避免影响用户体验。\n\n* JS 语句的执行不要超过 50 ms。\n\n* 任何 JS 任务都不应该执行超过 100 ms。过长的运行时间会导致 UI 更新出现明显的延迟，从而对用户体验产生负面影响。\n\n* 定时器可用来安排代码延迟执行，它使得你可以把长时间运行的脚本分解成一系列小的任务。\n\n* 定时器会在延迟时间到达后加入代码执行队列。\n\n* web worker 允许你在 UI 线程外部执行 JS 代码，从而避免锁定 UI。\n\n## Ajax\n\n> 高性能的 Ajax 需要选择正确的数据格式和与之匹配的传输技术。\n\n* JSON 和字符分割的自定义格式是最轻量和响应最快的选择。\n\n* XHR 提供了最完善的控制和灵活性，尽管它会把接收到的所有数据当作字符串。\n\n* 动态脚本注入可以跨域执行 JS 和 JSON，但不能读取信息头，且不安全。\n\n* Multipart XHR 可以用来减少请求数，并处理一个响应中的各种文件类型，但它不能缓存接收到的相应。\n\n* 当需要发送数据时，图片信标是一种简单有效的方法。\n\n* 以上介绍了几种 Ajax 技术： XHR， 动态脚本注入， MXHR，图片信标。Ajax 的存在使你可以不用在服务端就下发全部数据，或在不更新页面的情况下更新内容。\n\n* Ajax 缓存有两种方式：一种是在服务端设置缓存时间，一种是在客户端设置缓存数据变量。\n\n这里有一些使用准则\n\n* 减少请求数，可通过合并 JS 和 CSS文件，或使用 MXHR。\n\n* 缩短页面的加载时间，通过 Ajax 来在页面主要内容加载后，加载剩余内容。\n\n* 知道合适使用 Ajax 库，何时编写自己的 Ajax 代码。\n\n## 编程实践\n\n> JS 提出了一些独一无二的性能挑战，这与你组织代码的方式有关。\n\n* 避免使用 eval() 和 Function() 构造器带来双重求值的性能损耗。同样的，给 setTimeout 和 setInterval 传递函数而不是字符串作为参数。\n\n* 尽量使用直接量创建对象和数组，直接量的创建和初始化都比非直接量形式要快。\n\n* 避免重复的工作，当需要检测浏览器时，可使用延迟加载或条件预加载。\n\n* 在进行数学计算时，考虑使用直接操作数字的二进制形式的位运算。\n\n* 尽量使用 JS 原生方法。\n\n## 构建并部署高性能的 JS 应用\n\n> 构建与部署的过程对基于 JS 的 web 应用的性能有着巨大影响。\n\n* 合并 JS 文件以减少 HTTP 请求数。\n\n* 压缩 JS 文件。\n\n* 服务端压缩（Gzip 等）静态文件。\n\n* 通过正确设置 HTTP 响应头来缓存静态文件，通过向文件名增加时间戳来避免缓存问题。\n\n* 使用 CDN。\n\n\n\n> 在高压的环境下，人会快速的成长。",
      "data": {
        "title": "《高性能 javascript》总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-12-18-js-highPreformance"
    },
    {
      "content": "\n昨天碰到了一个关于缓存的问题，在搞明白的过程中有些收获，想着那就写一下。\n\n## 还是从问题的起源说起\n\n昨天在用深圳侧的组件的时候，发现组件开发同学稍前些时候上线的功能，自己这边并没有，看了一下源代码，原来是缓存的之前的。\n\n这里，有的人就要问了，为什么不用版本号，为什么呢？因为它是组件。\n\n## 性能优化\n\n在 web 2.0 的时代，追求页面加载速度的背景下，几乎所有的页面都会做不同程度的缓存处理，浏览器会通过协商缓存和强制缓存来确保加载速度。这里让我们来了解一下这些缓存机制。\n\n* 强制缓存\n\n    * Pragma\n\n    当该字段的 value 为 no-cache （现在仅有这个值）时，它会告诉浏览器不要读缓存，去服务器上取文件。\n\n    * Expires\n\n    Expires 的值是一个格林威治时间，在过期之前，浏览器会读浏览器的缓存。如果不想设置缓存，在 meta 标签里的 content 写为 0 或 -1\n\n    > 上面的这两个字段都是 http 1.0 时代的字段，现在已被弃用，但很多网站为了做向下兼容，还是添加了这两个字段。这两个字段在 meta 标签中设置的时候，只有 IE 浏览器会识别。这两个字段，Pragma 优先级更改。\n\n    * cache-control\n\n    针对上述的 `Expires时间是相对服务器而言，无法保证和客户端时间统一` 的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。\n\n* 协商缓存\n\n    为了让客户端和服务器之间实现缓存文件是否更新，更好的提高缓存复用率，Http 1.1 新增了几个字段\n\n    * Last-Modified\n\n    这个字段是服务器返回报文的一个字段，用来返回文件最后一次更改的时间，值是一个格林威治时间。\n\n    传递过来的最终修改时间会随着两个请求报文发送\n\n        1. If-Modified-Since\n\n        2. If-Unmodified-Since\n\n    Last-Modified 有一个不好的地方在于，如果服务器文件有改动，但实际内容并没有变化，这样就会导致重新下载文件。\n\n    * Etag\n\n    Etag 是服务器对资源进行某种算法得出的一个唯一标识符，通过它我们就可以解决 Last-modified 带来的不足\n\n    传递过来的唯一标识符通过请求报文的两个字段发送\n\n        1. If-None-Match\n\n        2. If-Match\n\n    如果 Last-modified 和 Etag 同时被使用，则两个都满足条件才会发送 304 ， nginx 默认同时开启。\n\n## 回到问题\n\n    为什么组件不好做缓存？\n\n    其实大多数的静态资源，我们是缓存的，缓存时间根据具体业务场景来定。\n\n    那么我们如何保证更改了文件之后能够让用户立刻感知。\n\n* 刷新 CDN\n\n    CDN 服务商会给我们提供刷新接口\n\n* 版本号\n\n    如何让用户的浏览器缓存失效？ 这里我们需要利用浏览器的缓存机制，浏览器缓存文件是按照 URL 缓存的，所以我们只需要更改请求文件的 URL 就行。所以我们可以给文件加上版本号。这样，每次版本上线之后，刷新版本号，就可以突破浏览器限制。\n\n    大多数情景下，问题已经得到了解决。\n\n    但是到了组件，就不好使了。\n\n    因为组件是每个工程模块引用的公共模块，如果组件跟新功能，那么在各模块不更新版本号的情况下，我们无法突破浏览器缓存限制。\n\n## 解决办法\n\n    我想到的办法就是特殊处理。\n\n    我们在设置服务器配置文件的时候，一般都会用正则给服务器的某一类型文件设置缓存时间。\n\n    所以，我们只需要设置一个白名单，将公共组件放进去，这样，保证该文件没有缓存时间，立即过期，就可以解决问题了。\n\n> 编码当如练刀，刀意内敛，一敛三年。\n\n\n\n\n    \n    \n",
      "data": {
        "title": "关于静态资源缓存的一点理解",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-4-12-cache"
    },
    {
      "content": "\n事情的起源是这样的。\n\n## 点击跳转指定位置\n\n前些天在做一个点击跳转指定位置的需求，在做这个的时候，出现了三种跳转方案。\n\n*  html 锚点\n\n这种方式很简单有效，我们只需要进行一点小小的改动\n\n```html\n    <a href='#jump'>点击跳转</a>\n    <div id='jump'>here</div>\n```\n\n* js 实现跳转代码\n\n我们需要利用 window.location 来实现\n\n```javascript\n    <script>\n    function jump() {\n         window.location.hash = \"#jump\";\n    }\n    </script>\n    <input  type=\"button\" name=\"Submit\" value=\"提交\"  onclick=\"jump()\" />\n\n    <div id=\"jump\">跳转到的位置</div>\n\n```\n\n这两种方法优势就是简单，但是缺点也很明显，它们会改变页面 URL ，这在一些时候，是不允许的。\n\n* 使用 animate 方法\n\n```javascript\n    $(\"html, body\").animate(\n        {\n            scrollTop: $(\"#div\").offset().top \n        }, \n        {\n            duration: 500,\n            easing: \"swing\"\n        }\n    )\n```\n这种方法不存在改变 URL 的情况，比较推荐。\n\n但在我使用这种方式完成跳转时，出现了一个问题，那就是页面在方法执行后没有反应。\n\n## 问题排查\n\n* scrollTop \n\nscrollTop 方法返回或设置匹配元素的滚动条的垂直位置，刚开始我以为是这个方法有问题，但在控制台我发现 DOM 节点下是有这个方法的，这个方法执行了，但就是没有跳转动作\n\n* 兼容性\n\n接着我想到了是不是浏览器没有做到这个方法的兼容，但是在同一浏览器的不同页面，这个方法是奏效的。\n\n* DOM 节点\n\n最后，我更换了 DOM 节点，将 html 换为了 window ，问题解决。\n\n## window document \n\n当时我是有些懵的，我不理解为什么更换为 window 对象后就好使了。于是我对 window document html body 这四个对象进行了一些对比了解。\n\n* window\n\nwindow 是指文档所在的窗口（没有包括浏览器的滚动条）\n\n* document \n\ndocument 的意思是文档，它是指具体的一个对象的内容，document 是 window 的一个子对象\n\n* html body\n\nhtml 和 body 指的是对应的 DOM 元素，一般在代码里面，body是包含在html里的，在标准浏览器里面html部分是等于body部分的\n\n## $(window).scrollTop() vs $(document).scrollTop()\n\n两者的效果相同，没有什么区别。但是，\n\n> In general use document mainly to register events and use window to do things like scroll, scrollTop, and resize\n\n所以为什么我之前使用 body 来执行 scrollTop 函数（原生 scrollTo）不行呢，是因为 body 并没有滚动条，html 的滚动条让 body 完全平铺展开了，所以如果我们用 `$(html,body)` ，那就不会错了。\n\n> 人生苦短，白驹过隙\n",
      "data": {
        "title": "window document html 与 body",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-4-9-dom"
    },
    {
      "content": "\n\n这半年多以来，一直在做移动端的网页开发，在移动端网页中，一大痛点就是调试代码，如何快速的定位问题，如何在特定的手机和浏览器中调试代码。\n\n在这里总结一下，下面的调试方法会冥冥之中有一个顺序，也可以当作我们选择调试时的一个顺序。以下方法的具体操作细节我不再赘述，网上有很多。\n\n## Eruda\n\n> Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等\n\n其实我们比较熟知的调试面板工具是 [Vconsole](https://github.com/Tencent/vConsole) ，但从功能上，我们可以明显看出，Eruda 在 Vconsole 之上。\n\n使用方法和 Vconsole 大同小异：\n\n* 在页面引入 js\n\n* 初始化方法\n\n这里我们注意一下：\n\nThe JavaScript file size is quite huge(about 100kb gzipped) and therefore not suitable to include in mobile pages. It's recommended to make sure eruda is loaded only when eruda is set to true on url(http://example.com/?eruda=true), for example:\n\n```javascript\n;(function () {\n    var src = 'node_modules/eruda/eruda.min.js';\n    if (!/eruda=true/.test(window.location) && localStorage.getItem('active-eruda') != 'true') return;\n    document.write('<scr' + 'ipt src=\"' + src + '\"></scr' + 'ipt>');\n    document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>');\n})();\n```\n[库地址](https://github.com/liriliri/eruda)\n\n## charles\n\n> Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet\n\ncharles 是一个抓包工具，这里之所以可以用来 debug ，是因为 charles 可以：\n\n* 修改网络协议\n\n* 替换请求文件\n\n当我们需要用本地的 js 文件来代替线上 js 文件进行调试时，charles 就帮了我们大忙，也弥补了 Eruda 无法对 js 进行太多操作的缺点。\n\ncharles 进行文件替换的原理很简单，就是在本地开了一个服务，然后起到了可以替换请求文件的中间件的作用。\n\n使用方法：\n\n* 开启 charles 软件\n\n* 手机与电脑在 wifi 下\n\n* 手机设置代理\n\n这里要注意的一点是，如果需要监听手机的 https 请求，需要给手机安装 charles 证书。\n\n## whistle\n\n> whistle is a cross-platform web debugging tool based on Node.js\n\nwhistle基本上覆盖了所有抓包调试代理可以实现的功能，它的横向对比工具还有 [spy-debugger](https://github.com/wuchangming/spy-debugger)。\n\n所以既然 whistle 可以代替 Eruda 和 charles（太重） ，那我们就没有必要使用它们了。\n\nwhistle 的功能很强大：\n\n* Weinre\n\n* Log\n\n    Log 主要是为了把控制台打印的信息展示出来，规则配置也很简单\n\n    > xx.yy.com log://xx\n    \n* proxy\n\n    代理的方法也很简单，在 whistle rules 里面配置需要代理的网址，然后用规则来转到线下\n\n    > pattern http://host:port/xxx\n\n## Safari 与 iphone\n\n其实，上面所讲的抓包调试代理有一个很大的缺点，那就是无法 debug js。在 iphone 机型下，为我们提供了解决方案。\n\n使用方法：\n\n* Mac Safari\n\n* iphone Safari\n\n* 数据线\n\n## Chrome 与 Android\n\n当然，在 android 机型下，也有相对应的解决方案。\n\n使用方法：\n\n* PC Chrome\n\n* Android Chrome\n\n* 数据线\n\n* 翻墙\n\n在使用这种调试方法的时候，可能会出现一些问题\n\n* inspect 后页面显示空白\n\n    解决方案：原因是被墙了，此服务需要连接谷歌的服务器，解决方法是翻墙，一般只需第一次 inspect 时翻，之后会缓存在本地。\n\n* inspect 页面显示 HTTP/1.1 404 Not Found\n\n    解决方案：原因是因为远程的浏览器（手机）版本比客户端（电脑）要新，需要在 chrome://inspect/#devices 下，使用 inspect fallback 进行监听。\n\n> `Safari 与 iphone` `Chrome 与 Android` 不能在手机的其他浏览器和 App webview 中使用，这可能会让我们在调试一些特定浏览器问题上没有解决途径，这是就需要搭配一些其他手段。比如 本地代理 + try catch\n\n## 总结\n\n* `Eruda` `charles` `whistle` 在解决问题时用到的较多\n\n* `Safari 与 iphone` `Chrome 与 Android` 在发现问题时用到的较多\n\n* 如果问题发生在特定浏览器上，可以搭配本地代理( whistle 等) + try catch 定位 bug\n\n> 这个世界就是不讲道理",
      "data": {
        "title": "移动端调试总结",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-9-1-mobile-debug"
    },
    {
      "content": "\n\n在上一篇性能分析总结中，我们从 API 的维度阐述了用户从输入 URL 到页面加载完成所经历了什么，自然而然的，我们想从浏览器的维护去理解一下这个问题。\n\n我们来看看开始解析 DOM 树（doming）后的步骤。\n\n在我们下载了文档之后，浏览器就开始解析 DOM 树，在解析 DOM 树的时候，我们需要用渲染引擎中的解析器。\n\n## 解析器\n\n解析器分为 `词法分析器` 和 `语法分析器` 两个组件。\n\n* 词法分析器\n\n    词法分析器负责将输入的内容分解为一个个有效的标记\n\n* 语法分析器\n\n    语法分析器根据当前语言的语言来将标记构建为解析树。\n\n\n\n",
      "data": {
        "title": "前端性能分析总结（二）",
        "date": "Invalid date",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-9-27-bowser"
    },
    {
      "content": "```javascript\nconst requestPool = (urls, num, callback) => {\n    const urlsPool = [...urls];\n    let pendPool = [];\n\n    const refresh = () => {\n        if (urlsPool.length) {\n            const url = urlsPool.pop();\n            requestHandle(url);\n        } else {\n            callback();\n        }\n    }\n\n    const requestHandle = async (url) => {\n        const key = Symbol(url);\n\n        pendPool.push(key);\n        const data = await fetch(url);\n        pendPool.filter((v) => {\n            return v !== key\n        });\n        refresh();\n\n        return data;\n    }\n\n    const limit = Math.min(num, urlsPool.length);\n\n    for (let i = 0; i < limit; i++) {\n        refresh();\n    }\n}\n```",
      "data": {
        "title": "实现 js 请求并发控制",
        "date": "2019-05-13 11:34:23",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "shi-xian-js-qing-qiu-bing-fa-kong-zhi"
    },
    {
      "content": "在 js 中所有数字都是以64位浮点数形式存储的\n\n64 位浮点数在内存中表示为： 最高一位 `符号位`， 11 位 `指数`， 52位`有效数字`。\n\n因为使用科学计数法，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分（有效数字）决定了数值的精度。\n\n最高位我们用 0 表示正数，用 1 表示负数\n\n这里的指数一共11个比特位，但是科学计数法中指数可以是负数，所以将其转为10进制数时，0 - 1022 表示负数，1024-2047表示正数。\n\n因为有效数字第一位必然是 1 ，这一位不保存在 64 位浮点数中。小数部分最长是52位，所以 js 提供的有效数字最长为 53 个二进制位（52 + 有效数字第一位的 1）。有人会说第一位不是只能是 1 吗？ 那不能单纯的算是 53 位，但是我们可以挪动指数位调整，所以是 53 位。\n\n所以 我们在这里可以推出：\n\n* js 的安全整数范围为正负 2的53次方，最大最小值是正负 2的53次方 - 1，由于指数为一位可以理解为正负，所以 js 表示数最大表示到 2 的 10 次方 - 1， 再大的数就是 js 中的 Infinity 了。\n\n* 如果是10进制的数字 `1`，那么它的浮点数第一位是 0，指数位是1023，小数位全部是0 （应为 1 是科学计数法第一位所以省略了）\n\n* 因为 `2^53=9007199254740992`，能够表示这么多的十进制数，共 16 位，这也是 JS 最多能够表示的精度。所以 x = 0.1 能够得到 0.1 ,因为0.1（52 位二进制为 `0.00011001100110011001100110011001100110011001100110011010`）在传给 x 的时候，做了精度运算，超过的会自动凑整。\n\n* 但是因为运算还是二进制运算，所以二进制 0.1 加 二进制 0.2 就会得到经典的 `0.30000000000000004`，这也就是博客题目所说的运算精度问题。整数的精度问题同样存在，因为在正负 2 的 53 次方之外的数已经没有了足够的比特位保存，所以会进行凑整保存，这样的数字就会有精度问题。\n\n当然，我们也有一些解决方案：\n\n数据展示类的数字我们可以直接采用 12 位精度来凑整处理。\n\n运算类的话，可以先将小数转成整数再运算。当然遇到一些数字精度大的数字时，我们可以采用一些较为成熟的解决库。\n这些处理较大数字的库，原理是先将其转为字符串，然后自己实现运算逻辑。如 `D.js`。\n\n参考资料：\n\n[两分钟解惑 JS 小数计算精度问题](https://juejin.im/entry/595f52356fb9a06bbd6f80c5)\n\n[JavaScript 浮点数运算的精度问题](https://www.html.cn/archives/7340)\n\n[JavaScript 里最大的安全的整数为什么是2的53次方减一？](https://www.zhihu.com/question/29010688)\n\n[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)\n\n[Here is what you need to know about JavaScript’s Number type](https://blog.angularindepth.com/javascripts-number-type-8d59199db1b6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "理解 js 浮点数运算精度问题",
        "date": "2019-05-10 14:55:21",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "li-jie-js-fu-dian-shu-yun-suan-jing-du-wen-ti"
    },
    {
      "content": "对于弱类型语言，我们会经常遇到类型转换的情景， 如果搞不懂原理，会在遇到类型转换的时候只能凭借过往的经验处理，但心里还是没有一个清晰的认知。\n\njs 的类型转换多发生在 `算数运算符`，`关系运算符`，`判断语句` 中，在这些场景中，类型会按照特定的规则，进行类型转换。我们来说说这些规则：\n\n首先在算数运算符中，除了 + 号以外，其他的如 - * / ，都需要将运算符两边的类型转换为 Number，js 引擎通过 ToNumber 方法来进行类型转换。\n\n如果算数运算符是 + 的话，如果有复杂类型，我们先将其转换为简单类型，在简单类型中（null, undefined, boolean,string,number）, 如果存在 string，我们将算数运算符两边转换为 string 对待。否则，将类型向 number 转换。\n\n其次是关系运算符，我们将运算符两边转换为基本类型后，如果两个操作数都是数值，则进行数值比较，如果两个操作数都是字符串，则进行按位比较。如果操作数有数值，则进行另一操作数数值转换。因为可能会有字符串与数值比较的情况，字符串转换为 NaN，NaN 与数字比较时，总是返回 false 。\n\n这里我们再讲一下 == 。双等运算符判断稍显复杂，如果类型相等，则直接比较，复杂类型需要看引用地址是否相同。如果类型不相等，如果有复杂类型，则先进行拆箱操作，转换为基本类型，接着就成了基本类型的比较了。第一种是数字和字符之间的比较，如果左操作数中是数字，则将另一操作数转换为数字，如果是字符，则自己转为数字。第二种是如果不是字符和数字的比较，其中有一个为boolean，则将boolean转换为数字。第三种，如果两个为null或者undefined,则返回true，当然如果只有一个，那就不说了，不要迷糊了。详细参见：\n\n[JavaScript隐式转换与拆箱](https://github.com/ck18781145809/blog/issues/2)\n\n这里还有几道练习题，可以试试看：\n\n[前端进阶系列（第3期）：常见的面试题 — 隐式类型转换](https://www.hankewins.com/blog/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%88%E7%AC%AC3%E6%9C%9F%EF%BC%89%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98-%E2%80%94-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)\n\n\n\n\n\n\n",
      "data": {
        "title": "js 隐式转换",
        "date": "2019-05-08 21:46:18",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "js-yin-shi-zhuan-huan"
    },
    {
      "content": "```javascript\n\t\t(function() {\n        var root = this;\n\n        var generateName = (function () {\n            var prefix = 0;\n\n            return function(descriptionStr){\n                prefix ++;\n                return '@@' + descriptionStr + '_' + prefix;\n            }\n        })()\n\n        var symbolPoyfill = function (description) {\n            if (root instanceof symbolPoyfill) throw new TypeError('symbol is not a constructor');\n\n            var descriptionStr = description == undefined ? undefined : String(description);\n\n            var symbol = Object.create({\n                toString: function() {\n                    return this.__Description__;\n                },\n                valueOf: function() {\n                    return this;\n                }\n            });\n\n            Object.defineProperties(symbol, {\n                '__Description__' : {\n                    value: generateName(descriptionStr),\n                    waritable: false,\n                    enumerable: false,\n                    configurable: false,\n                }\n            });\n\n            return symbol;\n        }\n\n        var forMap = {};\n\n        Object.defineProperties(symbolPoyfill, {\n            'for': {\n                value: function(key) {\n                    forMap[key] ? forMap[key] : forMap[descString] = symbolPoyfill(key)\n                },\n                waritable: true,\n                enumerable: false,\n                configurable: true\n            },\n            'keyFor': {\n                value: function(symbol) {\n                    for (var key in forMap) {\n                        if (forMap[key] === symbol) return key;\n                    }\n                },\n                waritable: true,\n                enumerable: false,\n                configurable: true\n            }\n        });\n\n\t\t\t\t\troot.SymbolPolyfill = symbolPoyfill;\n\t\t\t}\n\t\t)()\n```",
      "data": {
        "title": "实现 symbol Polyfill",
        "date": "2019-05-07 18:07:28",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "shi-xian-symbol-polyfill"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "```javascript\n\n    function Promise (executor) {\n\n        let _this = this,\n            _this.status = 'pending',\n            _this.value = undefined,\n            _this.reason = undefined,\n            _this.onResolvedCallbacks = [],\n            _this.onRejectedCallbacks = [];\n\n        function resolve (value) {\n            if (_this.status === 'pending') {\n                _this.status = 'resolved';\n                _this.value = value;\n\n                _this.onResolvedCallbacks.forEach(function(fn){\n                    fn();\n                });\n            }\n        };\n\n        function reject (reason) {\n            if (_this.status === 'pending') {\n                _this.status = 'reject';\n                _this.value = reason;\n\n                _this.onRejectedCallbacks.forEach(function(fn){\n                    fn();\n                });\n            }\n        };\n\n        try {\n            executor(resolve,reject);\n        } catch (e) {\n            reject(e);\n        }\n    }\n    \n    Promise.prototype.then = function(onFulfilled, onRejected) {\n\n        type onFulfilled === 'function' ? onFulfilled : function(value) {\n            return value;\n        }\n\n        type onRejected === 'function' ? onRejected : function(err) {\n            throw err;\n        }\n\n        let _this = this;\n        let promise2;\n\n        if (_this.status = 'pending') {\n            promise2 = new promise (function(resolve, reject) {\n                _this.onResolvedCallbacks.push(function(){\n                           \n                    try {\n                        let x = onFulfilled(_this.value);\n                        resolve(x);\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n                _this.onRejectedCallbacks.push(function(){\n\n                    try {\n                        let x = onRejected(_this.reason);\n                        resolve(x);\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }\n        }\n\n        if (_this.status = 'resolved') {\n\n            let x = onFulfilled(_this.value);\n            promise2 = new promise (function(resolve, reject) {\n                try {\n                    resolve(x);\n                } catch (e) {\n                    reject(e);\n                }\n            })\n        }\n\n        if (_this.status = 'rejected') {\n            \n            let x = onRejected(_this.reason);\n            promise2 = new promise (function(resolve, reject) {\n                try {\n                    resolve(x);\n                } catch (e) {\n                    reject(e);\n                }\n            })\n        }\n\n        return promise2;\n    }\n\n    Promise.prototype.resolve = function (value) {\n        return new Promise(function(resolve,reject){\n            resolve(value);\n        })\n    }\n\n    Promise.prototype.reject = function (reason) {\n        return new Promise(function(resolve,reject){\n            resolve(reason);\n        })\n    }\n\n    Promise.prototype.race = function (promises) {\n        return new Promise(function(resolve,reject){\n            for ( let i = 0; i < promises.length; i ++) {\n                promises[i].then(resolve,reject);\n            }\n        })\n    }\n\n    Promise.prototype.all = function (promises) {\n        return new Promise(function(resolve,reject){\n\n            let arr = [];\n            let i = 0; \n\n            function processData(index, y) {\n                arr[index] = y;\n                if (++index === promises.length) {\n                    resolve(arr);\n                }\n            }\n\n            for ( let i = 0; i < promises.length; i ++) {\n                promises[i].then(function(y){\n                    processData(i, y)\n                },reject);\n            }\n        })\n    }\n\n    module.exports = Promise\n```\n\n### 参考资料\n\n[可能是目前最易理解的手写promise](https://juejin.im/post/5dc383bdf265da4d2d1f6b23)",
      "data": {
        "title": "手写一个 promise",
        "date": "2019-01-25 09:56:02",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2019-1-25-hand-promise"
    },
    {
      "content": "👏  欢迎使用 **Hve Notes** ！  \n\nGithub: [Hve Notes](https://github.com/hve-notes/hve-notes)  \n项目主页: [Hve Notes](http://hvenotes.fehey.com/)  \n示例网站: [示例网站一](http://fehey.com/) [示例网站二](http://hve-notes.github.io)  \n\n✍️  **Hve Notes** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题  \n\n\n🌱 当然 **Hve Notes** 还很年轻，有很多不足，但请相信，它会不停向前🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Hve Notes",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "HveNotes"
        ],
        "published": true,
        "hideInList": true,
        "feature": "/post-images/hello-hve-notes.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "hello-hve-notes"
    },
    {
      "content": "\n\n写这篇文章的目的，主要是为了让自己对学习到的知识进行提炼和梳理，对于可以在网上找到答案的东西，没必要再次写出来。\n\n## 什么是 CSRF\n\ncross site request forgery , 攻击者诱导用户进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取到的注册凭证，绕过后台验证，冒充用户对被攻击网站执行某种操作的目的。\n\n攻击流程：\n\n- 用户登陆被攻击网站 a.com ，并保留了登陆凭证。\n\n- 攻击者诱导用户访问了第三方网站 b.com\n\n- 期间第三方网站向被攻击网站发送了 a.com?act=xxx,浏览器默认携带了 a.com 的 cookie\n\n- a.com 接到请求，并验证登陆凭证，误以为是用户发送的请求\n\n- a.com 执行了 a.com?act=xxx 请求\n\n- 攻击完成，攻击者冒充用户，完成了请求执行\n\n## 攻击类型\n\n* GET 请求\n\n    图片请求\n\n* POST 请求\n\n    表单\n\n* 链接\n\n    恶意链接，诱导点击\n\n## CSRF 特点\n\n* 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n\n* 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n\n* 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n\n* 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\nCSRF 大多发生在外域来进行攻击，但是如果主要可以被潜入上面的三种攻击类型，那么也可以在本域进行攻击，且更加难以防御。\n\n## 防御\n\n- 首先发生在本域的攻击，这里我们可以对本域的类似评论区等可以嵌入请求和链接的地方进行处理，采取禁止外链或提示等操作。\n\n- 如果攻击发生在外域，那么我们需要从两个角度来思考防御\n\n    * 攻击发生在外域\n\n        * 同源检测\n\n            * Origin Header\n\n            * Referer Header\n\n        * Samesite Cookie\n\n    * 攻击者不能获取 cookie ，只能冒用\n\n        * CSRF Token\n\n        * 双重Cookie验证\n\n参考资料：\n\n[ 前端安全系列之二：如何防止CSRF攻击？](https://segmentfault.com/a/1190000016659945)",
      "data": {
        "title": "前端安全（二）CSRF 防御",
        "date": "2018-11-10 14:20:19",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-11-10-csrf"
    },
    {
      "content": "\n\n今天写这么一篇文章，完全是因为自己前些日子碰到的 web 安全问题，自己有了些许经历，所以准备写下来。网上有很多优秀的讲述 web 安全的文章，其中尤为推荐[美团技术团队](https://segmentfault.com/u/meituanjishutuandui)写的系列文章。\n\n当然，网上已有的东西再重写一遍毫无意义，所以我记录的，只是在我看来需要再度提炼和注意的地方。\n\n## 什么 是 XSS \n\n> Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\n\n## XSS 的种类\n\n|类型|存储区|插入点|\n|---|---|---|\n|存储型 XSS |后端数据库 |HTML|\n|反射型 XSS |URL    |HTML|\n|DOM型 XSS |后端数据库/前端存储/URL    |前端 JavaScript|\n\n## XSS 攻击要素\n\n* 攻击者提交恶意代码\n\n* 浏览器执行恶意代码\n\n## XSS 防御\n\n我们可以从 XSS 攻击要素和代码层面两个方面来考虑防御\n\n* 从攻击要素防御\n\n    * 攻击者提交恶意代码\n\n    思路：这里能够使用的方法，就是`输入过滤`。\n\n    方法：但在这里做的话有一个问题，前端做过滤可以绕过，后端做过滤又无法预测前端如何展现，当作 HTML 进行展示当然没有问题，但如果当作文本的话，就会出现乱码。\n\n    乱码问题倒是可以解决，在前端，利用反转义重新处理。\n\n    那可以直接不从提交恶意代码角度进行防御吗？既不使用输入过滤？\n\n    * 浏览器执行恶意代码\n\n        从两个思路来解决：\n\n        * 防止 HTML 中出现注入\n\n        * 防止 JavaScript 执行时，执行恶意代码\n\n        方法：\n        \n        * 后端模版渲染改成纯前端 HTML 渲染，把代码和业务数据分隔开，我们明确的在插入数据阶段选择 HTML 插入或者文本插入。但这样还是存在两个问题，一个是首屏加载问题，一个是 DOM XSS 须单独解决。\n\n        * HTML 转义，说到底，还是进行输入过滤。\n\n    > 由此可以得出，在不能改变后端渲染的前提下，输入过滤是无法避免的。如果改为前端渲染，只需关心 DOM XSS 就好了。至于 DOM XSS，在一些本地存储的场景下，过滤转义也无法避免。\n\n* 从代码层面考虑防御\n\n    我们可以从代码层面来预发和警惕 XSS 攻击。\n\n    我们需要知道 XSS 攻击的来源。\n\n    由上面的 XSS 种类可知，途径大概有以下这些。\n\n    * 用户的 UGC 信息\n\n    * 第三方的链接\n\n    * URL 参数\n\n    * POST 参数\n\n    * Referer （可能来自不可信的来源）\n\n    * Cookie （可能来自其他子域注入）\n\n    * HTML 属性（href，src，style的background-image:url和expression(...)）\n\n    * onload、onerror、onclick、location、onmouseover 等事件\n\n    > 代码层面考虑防御是要求开发者在遇到上述情况足够的警觉，考虑此处是否会出现 XSS 攻击，如果会出现，那么解决方案还是`攻击要素防御`的解决方案。\n\n* 其他防御\n\n    这里列举一些其他的防御手段，当然，这些手段可能无法在所有情况下解决问题。\n\n    * CSP\n\n    * 输入内容长度控制\n\n    * HTTP-only Cookie\n\n    * 验证码\n\n`当然，上面所有的考虑只是出自前后端数据通信安全的前提下，但是 HTTPS 也不一定万无一失`\n\n> 时间已经来到了下半场，剩下的只有残酷的白刃战。\n\n\n\n\n",
      "data": {
        "title": "前端安全（一）XSS 防御",
        "date": "2018-11-07 14:14:36",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2018-11-7-xss"
    },
    {
      "content": "\n做 Web 页面的移动端开发的时候，需要对移动端设备的尺寸，分辨率，屏幕种类还有如何最大程度还原设计效果有清晰的认识。这些知识网上也有，但大多都有些错误，所以自己记\n录下来，留作参考与分享。\n\n## 一般我们会遇到这几个问题：\n\n* chrome device 模式下的数值的单位\n* &lt;meta name='viewport' content='width=device-width，initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=yes'> 的作用\n* 手机像素和 visual viewport 的关系\n\n我们需要清楚有关像素的几个概念：\n\n* 分辨率\n* 设备像素\n* 设备独立像素\n* css 像素\n* PPI\n* DPR\n\n### 分辨率\n\n泛指量测或显示系统对细节的分辨能力，分辨率越高越能表现出更多的细节，但相对的，因为记录的信息更多，文件也就会越大。\n\n![](http://121.42.215.169/blog_images/pixel.PNG)\n\n1920\\*1080（推荐）意味着这个电脑在横向上设置了 1920 个像素，纵向上设置了 1080 个像素，当然电脑上的分辨率是可以调节的，但只是有效像素个数减少了。\n\n### 设备像素\n\n设备像素即 physic pixel，就是设备的像素大小。比如 iPhone 6 Plus 的物理分辨率为 1080\\*1920\n\n### 设备独立像素\n\n也叫密度无关像素，代表着可以由程序使用并控制的虚拟像素，设备虚拟像素和设备像素之间存在着一定的对应关系。这个在后面会讲到。\n\n### css 像素\n\n前端工程师在编写网页时用到的 css 像素单位，是抽象的，不是实际存在的。\n\n### PPI\n\n![](http://121.42.215.169/blog_images/ppi.png)\n\n### DPR\n\n即device pixel route ，在同一方向上的设备像素与设备独立像素的比值。它也有一个别名叫做scale，在iPhone里面的 scale 有1x,2x,3x而Android里面就多了。\n我们要知道在手机移动端的几个概念：\n\n* visual viewport\n* layout viewport\n* ideal viewport\n\n### visual viewport\n\n虚拟视口。它是手机的页面绘制区，大小不一，以设备独立像素为单位。\n计算方法：document.documentElement.clientWidth，document.body.clientWidth(IE)\n\n### layout viewport\n\n布局视口。它是手机需要展示的页面总区域。它在不同的浏览器中，大小也是不同的\n   \n    Safari iPhone:980px\n    Opera:850px\n    Android Webkit:800px\n    IE:974px\n计算方法：window.innerWidth\n\n### ideal viewport\n\n理想视口。一般当我们使用 &lt;meta name='viewport'  content='width=device-width'> 时可以得到。\n\n![](http://121.42.215.169/blog_images/visualviewport.jpg) ![](http://121.42.215.169/blog_images/layoutviewport.jpg)\n\n**如果我们把 viewport 当做打开的高德地图，那么 visual viewport就是打开时显示的局部地图，layout viewport就是缩小地图后显示的总地图， ideal viewport 就是我们将总地图的宽度\n变为了 visual viewport 的宽度。**\n\n有了这些基础后，再来解决上面的问题\n\n### 那我们平时 chrome 下的 device 模式，它是什么像素呢？\n\n![](http://121.42.215.169/blog_images/device.PNG)\n\n利用上面计算visual viewport 和 layout viewport 的方法，我们计算出 device 模式的像素与 visual viewport的像素一致，是设备独立像素，在数值上等于 css 像素。\n\n![](http://121.42.215.169/blog_images/test.PNG)\n\n### 上面讲过的 &lt;meta name='viewport' content='width=device-width'>，它在常见的响应式页面中到底起什么作用？\n\nmeta viewport 最早是由苹果公司提出的，后被 MSN 引为规范，其中:\n\n    width=device-width:表示宽度是设备屏幕的宽度\n    initial-scale:表示初始的缩放比例\n    minimum-scale:表示最小的缩放比例\n    maximum-scale:表示最大的缩放比例\n    user-scalable:表示用户是否可以调整缩放比例\n    \n用两个 demo 可以很清楚的说明问题\n\n[查看示例](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ui/responsive/vp-no.html) [查看示例](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ui/responsive/vp.html)\n\n当然，如果你使用过宽的css绝对宽度或者较大的绝对定位值，那么 width=device-width 是不会起作用的，建议使用相对宽度值，例如 width:100%\n\n### 手机像素和 visual viewport 的关系\n\n这里的visual viewport 也就是手机整个屏幕可显示内容的多少\n要理解两者的关系，我们先来看看一张表格\n\n| 设备 | iPhone 3Gs | 4(s) | 5c | 6 | 6+ |\n| --- | --- | --- | --- | --- | --- |\n| 设备分辨率 | 320\\*480 | 640\\*960 | 640\\*1136 | 750\\*1334 | 1080\\*1920 |\n| 对角线(inh) | 3.5 | 3.5 | 4 | 4.7 | 5.5 |\n| visual viewport | 320\\*480 | 320\\*480 | 320\\*568 | 375\\*667 | 414\\*736 |\n| scale | @1x | @2x | @2x | @2x | @3x |\n| PPI | 163 | 326 | 326 | 326 | 401 |\n\n我们可以看出来很明显的公式痕迹,设备分辨率，逻辑像素（即 visual viewport）与 scale，当然三者之间并没有明显的从属关系，而是相互影响。\n这里还有几个问题需要注意:\n\n* 映射\n\n从上面的表格可以看出iPhone 6 plus的逻辑像素是414\\*736，但如果手机设计者不设计为这个尺寸，但物理分辨率（设备分辨率）和scale 不变呢，那么手机就不得不把逻辑像素不是\n414\\*736的元素强行放大或缩小到屏幕上，这就是映射。\n\n* 界面 UI 元素的物理大小\n\n我们首先清楚一个概念，当逻辑像素一定时，它在一行可显示的内容是有限的，比如如果字体大小一定，iPhone 6 一行只能显示确定的字数。\n那么我们可以做一个假设，当layout viewport 一定时，width=100%，这一行显示的元素，比如字体和按键，是会因为逻辑像素的增加而增加，但手机屏幕的物理大小是不变的，这就\n会导致映射而字体与按钮变小，更难阅读和点击。\n\n* retina 显示屏\n\n讲到这里，就又有一个名词不得不讲，那就是 retina 视网膜显示屏。因为它很容易产生 scale，所以更容易与 scale 混淆，而影响我们对上述问题的判断。\nretina 视网膜屏幕是 Apple 公司在 iPhone4 的时候推出的一种显示屏，因为有着人肉眼无法分辨的像素点，所以画面显示相当细腻，不难猜出，要在与以前相差不大的屏幕上得到这\n样的效果，那么对于分辨率的要求是相当高的，即在手机上，必须有大于 300 的 PPI 才可以做到。\nretina 屏幕的判断标准是在第三代 iPad 大会上提出的\n\n![](http://121.42.215.169/blog_images/retina.jpg)\n\n为什么要叫做 retina 显示屏，我更倾向于这是一种噱头，人们赞美 Apple 制造的 retina 显示屏，与其说是因为给了大众一种更加好的用户体验（超高的分辨率，不过其实有好几家\n韩国与日本的厂家早已研发了出来），不如说 Apple 极致的垂直产品制造让它进入大众生活更贴切一些。 \n\n[参考资料](https://www.yuque.com/qqqqqcy/original)\n",
      "data": {
        "title": "前端工程师在移动端开发中遇到的像素问题",
        "date": "2016-10-27 18:12:25",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-10-27-px"
    },
    {
      "content": "\n\n截止今天为止，凡是我遇到的部署博客的问题，无论是 Jekyll 还是 Hexo 方面的，都一一有了答案，想着，写一篇博客，当做总结 。\n\n### 部署前提\n\n在 Github 上面申请一个仓库，仓库的名词必须是 username.github.io\n\n* Jekyll 部署方案\n\n        Jekyll 是一个简单的博客形态的静态站点生产机器。 它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如Markdown）\n        和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。\n这个引擎在 github 的服务器上就有，所有我们要做的仅仅是将自己的文件按照 jekyll 引擎可以渲染的目录结构 push 上 github 就可以了\n    \n    * Jekyll 的目录结构\n    \n            .   \n            |--_config.yml>  \n            |--_drafts  \n                   |--articles1.textile \n                |--articles2.md\n            |--_includes\n                |--footer.html\n                |--header.html\n            |--_layouts\n                |--default.html\n                |--post.html\n            |--_posts\n                |--2014-06-17-articles1.textile\n                |--2014-06-17-articles1.md\n            |--_site\n            |--index.html\n            |--other files\n    \n    \n    网上关于 jekyll 目录结构的讲解文章有很多，我就不在这里赘述了，文末会有参考资料。\n    \n    * Jekyll 解析流程\n            \n        * 首先会加载_posts及文件夹下的所有文章，将其参数和文章内容组织保存在内存中，所有的文章的内容、参数都在site.posts对象（其他文件夹下的文章不会放入site.posts中）。\n        * 其次加载_layouts文件夹下的所有模板。\n        * 再次加载_includes文件夹下的所有需要被引入的内容。\n        * 最后根据每一篇需要编译的文章选择的其参数定义的模板来创建一个模板，并将当前文章的内容、参数等进行扩展后放在page对象、content对象中，然后进行模板的编译，生成html文件，并按照一定规则放在_site文件夹下。也就是说在创建一篇文章时，其实所有文章的内容都已经被读取出来了，这也为文章相互之间的关联提供了可能。\n         \n        \n        正是由于 jekyll 会在渲染一篇文章时将其他文章也一并加载，所以 jekyll 只适合搭建中小型博客。 \n        \n        * 由于 Github Pages 完美支持 Jekyll ，所以你只需要安照 Jekyll 的文件目录结构，托管在 Github 中即可，不需要在本机安装 Jekyll ，只需要关注于 Github，可以借鉴大师们设计的 Jekyll 模板，然后 push 或 pull 你的文章即可。\n            * 新建一个文件夹，并且初始化仓库。\n            * git clone 你的 username.github.io 仓库\n            * 找一个大师的[模板](https://github.com/jekyll/jekyll/wiki)，然后放进自己的本地文件夹\n            * 更改大师的配置，push 到 Github 中\n            \n        * 访问 username.github.io\n        * 关于评论\n            评论我使用的是 Disqus ，你只需要注册一个账号，然后把插件代码复制到自己的 _layouts 里的模板中就可以了，不过这里要注意布局，建议使用 [footer 布局](https://sfmonkey.github.io/blog/2016/07/footer.html)中的推拉退布局\n    \n    * Hexo 部署方案\n    \n            Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n        \n        * 准备环境\n            * Nodejs\n                \n                * Windows\n                    * 前往[官网](https://nodejs.org/en/)下载安装\n                * ubantu\n                    * sudo apt-get install nodejs\n        \n        * 安装 Hexo\n        \n            创建一个文件夹并初始化它，下面的一些命令不清楚的，文末有相关资料，注意 npm 的使用位置，一定要是你创建的文件夹，nodejs 的安装源很重要，否则可能出现错误。\n            \n            *  npm install hexo-cli -g\n                \n                可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。\n           \n            *  npm install hexo --save\n            \n                然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了\n                \n            *  hexo -v        \n            *  hexo init\n                \n                初始化\n            *  npm install\n            \n                安装所需组件\n            *  hexo g\n            *  hexo s\n                在浏览器中打开http://localhost:4000/，本地 Hexo 搭建成功\n            \n            *  配置 Deployment\n                \n                    git config --global user.name \"yourname\"\n                    git config --global user.email \"youremail\"\n            *   同样在_config.yml文件中，找到Deployment，然后按照如下修改\n            \n                    deploy:\n                      type: git\n                      repo: git@github.com:yourname/yourname.github.io.git\n                      branch: master\n            *  npm install hexo-deployer-git --save\n                如果使用git方式进行部署，执行npm install hexo-deployer-git --save来安装所需的插件\n            \n            *  Hexo d\n            *  hexo d -g\n                \n                部署博客\n            *  username.github.io\n    \n    关于更改域名等不在这里说了，网上有很多，文末我会附上资料。\n    \n    \n    \n    \n    \n    补充: 前天部署的时候突然出现问题，由于 Github 没有发来邮件提醒，而我的文章又只出现在 Github 上而未出现在博客上，导致我以为是时区问题造成的 future 未发布，其实不然，问题出现在了编码问题上，由于 Github 不知为何未发错误邮件，所以好久都没找到问题所在。 \n    \n### 相关资料: \n[Git+GitHub+Markdown+Jekyll=Perfect Personal Blog](http://www.devtalking.com/articles/git-gitHub-markdown-jekyll/)\n\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n\n[史上最详细的Hexo博客搭建图文教程](https://xuanwo.org/2015/03/26/hexo-intor/)\n\n[文档 Hexo](https://hexo.io/zh-cn/docs/)\n          ",
      "data": {
        "title": "github pages 部署总结",
        "date": "2016-07-25 16:30:23",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2016-7-25-githubpages"
    }
  ],
  "tags": [
    {
      "index": 7,
      "name": "Babel",
      "slug": "PcrNP95Kt",
      "used": true
    },
    {
      "index": 6,
      "name": "Vue",
      "slug": "V8_eyJVRg",
      "used": true
    },
    {
      "index": 5,
      "name": "React",
      "slug": "t1GPgLh46",
      "used": true
    },
    {
      "index": -1,
      "name": "component",
      "slug": "sJxDYj1YY",
      "used": true
    },
    {
      "index": -1,
      "name": "Essay",
      "slug": "yldW1tuxF",
      "used": true
    },
    {
      "index": -1,
      "name": "webpack",
      "slug": "fq56-p2wF",
      "used": true
    },
    {
      "name": "blog",
      "slug": "blog",
      "used": true
    },
    {
      "name": "HveNotes",
      "slug": "hvenotes",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}