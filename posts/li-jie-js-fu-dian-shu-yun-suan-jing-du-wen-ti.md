---
title: 理解 js 浮点数运算精度问题
date: 2019-05-10 14:55:21
tags: []
published: true
hideInList: false
feature: 
---
在 js 中所有数字都是以64位浮点数形式存储的

64 位浮点数在内存中表示为： 最高一位 `符号位`， 11 位 `指数`， 52位`有效数字`。

因为使用科学计数法，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分（有效数字）决定了数值的精度。

最高位我们用 0 表示正数，用 1 表示负数

这里的指数一共11个比特位，但是科学计数法中指数可以是负数，所以将其转为10进制数时，0 - 1022 表示负数，1024-2047表示正数。

因为有效数字第一位必然是 1 ，这一位不保存在 64 位浮点数中。小数部分最长是52位，所以 js 提供的有效数字最长为 53 个二进制位（52 + 有效数字第一位的 1）。有人会说第一位不是只能是 1 吗？ 那不能单纯的算是 53 位，但是我们可以挪动指数位调整，所以是 53 位。

所以 我们在这里可以推出：

* js 的安全整数范围为正负 2的53次方，最大最小值是正负 2的53次方 - 1，由于指数为一位可以理解为正负，所以 js 表示数最大表示到 2 的 10 次方 - 1， 再大的数就是 js 中的 Infinity 了。

* 如果是10进制的数字 `1`，那么它的浮点数第一位是 0，指数位是1023，小数位全部是0 （应为 1 是科学计数法第一位所以省略了）

* 因为 `2^53=9007199254740992`，能够表示这么多的十进制数，共 16 位，这也是 JS 最多能够表示的精度。所以 x = 0.1 能够得到 0.1 ,因为0.1（52 位二进制为 `0.00011001100110011001100110011001100110011001100110011010`）在传给 x 的时候，做了精度运算，超过的会自动凑整。

* 但是因为运算还是二进制运算，所以二进制 0.1 加 二进制 0.2 就会得到经典的 `0.30000000000000004`，这也就是博客题目所说的运算精度问题。整数的精度问题同样存在，因为在正负 2 的 53 次方之外的数已经没有了足够的比特位保存，所以会进行凑整保存，这样的数字就会有精度问题。

当然，我们也有一些解决方案：

数据展示类的数字我们可以直接采用 12 位精度来凑整处理。

运算类的话，可以先将小数转成整数再运算。当然遇到一些数字精度大的数字时，我们可以采用一些较为成熟的解决库。
这些处理较大数字的库，原理是先将其转为字符串，然后自己实现运算逻辑。如 `D.js`。

参考资料：

[两分钟解惑 JS 小数计算精度问题](https://juejin.im/entry/595f52356fb9a06bbd6f80c5)

[JavaScript 浮点数运算的精度问题](https://www.html.cn/archives/7340)

[JavaScript 里最大的安全的整数为什么是2的53次方减一？](https://www.zhihu.com/question/29010688)

[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)

[Here is what you need to know about JavaScript’s Number type](https://blog.angularindepth.com/javascripts-number-type-8d59199db1b6)













